This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: app, components, contracts, lib, prisma/schema.prisma
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
app/
  api/
    auth/
      logout/
        route.js
      wallet/
        route.js
    challenges/
      [id]/
        daily-exercise/
          route.js
        update-contract/
          route.js
        route.js
      complete/
        route.js
      create/
        route.js
      daily-progress/
        route.js
      join/
        route.js
      practice-info/
        route.js
      update-progress/
        route.js
      user/
        route.js
    conversation/
      evaluate/
        route.js
      route.js
    users/
      activity/
        route.js
      analytics/
        route.js
      profile/
        route.js
  auth/
    signin/
      page.jsx
  dashboard/
    challenges/
      [id]/
        page.jsx
      create/
        page.jsx
      page.jsx
    learn/
      page.jsx
    statistics/
      page.jsx
    page.jsx
  globals.css
  layout.js
  page.js
components/
  auth/
    LogoutButton.jsx
    UserProfileForm.jsx
    WalletConnectButton.jsx
  challenge/
    CreateChallengeForm.jsx
    JoinChallengeFlow.jsx
    YieldInformation.jsx
  dashboard/
    ChallengeCard.jsx
    LanguageStats.jsx
    RecentActivity.jsx
  layout/
    DashboardLayout.jsx
  learn/
    ConversationInterface.jsx
  ui/
    button.jsx
    EmptyState.jsx
    ErrorMessage.jsx
    LoadingSpinner.jsx
    LoadingState.jsx
    TransactionStatus.jsx
contracts/
  StakingChallenge.sol
lib/
  auth/
    jwt.js
    verify.js
  cron/
    dailyCheck.js
  web3/
    abis/
      stakingABI.json
      usdcABI.json
    hooks/
      useContract.js
      useStaking.js
    providers.js
    staking.js
  utils.js
prisma/
  schema.prisma

================================================================
Files
================================================================

================
File: app/api/auth/logout/route.js
================
// app/api/auth/logout/route.js
import { cookies } from 'next/headers';
import { NextResponse } from 'next/server';

export async function POST() {
  // Clear the auth token cookie
  const cookieStore = await cookies();
  cookieStore.delete('auth_token');
  
  return NextResponse.json({ success: true });
}

================
File: app/api/auth/wallet/route.js
================
// File: app/api/auth/wallet/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { ethers } from 'ethers';
import { cookies } from 'next/headers';
import { SignJWT } from 'jose';
import { nanoid } from 'nanoid';

const prisma = new PrismaClient();

// Generate nonce for signing
export async function GET(request) {
  try {
    const walletAddress = request.nextUrl.searchParams.get('address');
    
    if (!walletAddress) {
      return NextResponse.json({ error: 'Wallet address is required' }, { status: 400 });
    }
    
    // Generate a random nonce
    const nonce = nanoid();
    
    const cookieStore = await cookies();
    // Store nonce in cookies for later verification
    cookieStore.set('auth_nonce', nonce, { 
      httpOnly: true, 
      secure: process.env.NODE_ENV === 'production',
      maxAge: 5 * 60, // 5 minutes
      path: '/' 
    });
    
    const message = `Welcome to ShinobiSpeak!\n\nPlease sign this message to verify your wallet ownership.\n\nThis request will not trigger a blockchain transaction or cost any gas fees.\n\nWallet address: ${walletAddress}\nNonce: ${nonce}`;
    
    return NextResponse.json({ message });
  } catch (error) {
    console.error('Error generating nonce:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

// Verify signature and authenticate user
export async function POST(request) {
  try {
    const { walletAddress, signature } = await request.json();
    
    if (!walletAddress || !signature) {
      return NextResponse.json({ error: 'Wallet address and signature are required' }, { status: 400 });
    }
    
    // Get nonce from cookies
    const nonce = await cookies().get('auth_nonce')?.value;
    
    if (!nonce) {
      return NextResponse.json({ error: 'Authentication nonce not found or expired' }, { status: 401 });
    }
    
    // Recreate the message that was signed
    const message = `Welcome to ShinobiSpeak!\n\nPlease sign this message to verify your wallet ownership.\n\nThis request will not trigger a blockchain transaction or cost any gas fees.\n\nWallet address: ${walletAddress}\nNonce: ${nonce}`;
    
    // Verify the signature
    const recoveredAddress = ethers.verifyMessage(message, signature);
    
    if (recoveredAddress.toLowerCase() !== walletAddress.toLowerCase()) {
      return NextResponse.json({ error: 'Invalid signature' }, { status: 401 });
    }
    
    // Find or create user
    let user = await prisma.user.findUnique({
      where: { walletAddress },
    });
    
    const isNewUser = !user;
    
    if (!user) {
      // Create new user with just wallet address
      user = await prisma.user.create({
        data: {
          walletAddress,
          username: `user_${walletAddress.slice(0, 6)}`, // Temporary username
        },
      });
    }
    
    // Create JWT token
    const secret = new TextEncoder().encode(process.env.JWT_SECRET);
    const token = await new SignJWT({ 
      userId: user.id,
      walletAddress: user.walletAddress 
    })
      .setProtectedHeader({ alg: 'HS256' })
      .setIssuedAt()
      .setExpirationTime('7d')
      .sign(secret);
    
    // Clear nonce cookie
    const cookieStore= await cookies();
    cookieStore.delete('auth_nonce');
    
    // Set auth token cookie
    cookieStore.set('auth_token', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 7 * 24 * 60 * 60, // 7 days
      path: '/'
    });
    
    return NextResponse.json({ 
      success: true, 
      user: {
        id: user.id,
        walletAddress: user.walletAddress,
        username: user.username,
        isProfileComplete: Boolean(user.username && user.email && user.nativeLanguage),
        isNewUser
      }
    });
  } catch (error) {
    console.error('Error authenticating user:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

================
File: app/api/challenges/[id]/daily-exercise/route.js
================
// app/api/challenges/[id]/daily-exercise/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request, { params }) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const { id } = params;
    
    if (!id) {
      return NextResponse.json({ error: 'Challenge ID is required' }, { status: 400 });
    }
    
    // Check if challenge exists and user is participating
    const userChallenge = await prisma.userChallenge.findFirst({
      where: {
        challengeId: id,
        userId: auth.userId,
        status: 'ACTIVE'
      },
      include: {
        challenge: true
      }
    });
    
    if (!userChallenge) {
      return NextResponse.json({ error: 'Challenge not found or user not participating' }, { status: 404 });
    }
    
    // Get today's date
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Check if there's already a daily progress record for today
    const todayProgress = await prisma.dailyProgress.findUnique({
      where: {
        userChallengeId_date: {
          userChallengeId: userChallenge.id,
          date: today
        }
      }
    });
    
    // Determine exercise based on progress
    let exercise;
    let description;
    
    if (todayProgress && todayProgress.completed) {
      description = "You've already completed today's goal! Keep practicing for extra progress.";
      exercise = `You've practiced ${todayProgress.minutesPracticed} minutes today. Your goal was ${userChallenge.challenge.dailyRequirement} minutes.`;
    } else if (todayProgress) {
      description = "Continue your daily practice to reach your goal!";
      exercise = `You've practiced ${todayProgress.minutesPracticed} minutes today. You need ${userChallenge.challenge.dailyRequirement - todayProgress.minutesPracticed} more minutes to reach your daily goal.`;
    } else {
      description = "Start your daily practice to maintain your streak!";
      exercise = `Practice ${userChallenge.challenge.dailyRequirement} minutes of ${getLanguageName(userChallenge.challenge.languageCode)} today.`;
    }
    
    return NextResponse.json({
      description,
      exercise,
      challengeId: id,
      userChallengeId: userChallenge.id,
      dailyRequirement: userChallenge.challenge.dailyRequirement,
      currentProgress: todayProgress?.minutesPracticed || 0
    });
  } catch (error) {
    console.error('Error fetching daily exercise:', error);
    return NextResponse.json({ error: 'Failed to fetch daily exercise' }, { status: 500 });
  }
}

// Helper function to get language name
function getLanguageName(code) {
  const languages = {
    'en': 'English',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'it': 'Italian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'ru': 'Russian',
    'pt': 'Portuguese',
    'ar': 'Arabic',
    'hi': 'Hindi'
  };
  
  return languages[code] || code;
}

================
File: app/api/challenges/[id]/update-contract/route.js
================
// app/api/challenges/[id]/update-contract/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function POST(request, { params }) {
  try {
    // Verify authentication
    const auth = await verifyAuth();
    
    if (!auth.success) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const { id } = params;
    
    if (!id) {
      return NextResponse.json({ error: 'Challenge ID is required' }, { status: 400 });
    }
    
    // Parse request body
    const body = await request.json();
    const { transactionHash, contractAddress, contractChain } = body;
    
    if (!transactionHash || !contractAddress) {
      return NextResponse.json({ 
        error: 'Transaction hash and contract address are required' 
      }, { status: 400 });
    }
    
    // Check if challenge exists and user is the creator
    const challenge = await prisma.challenge.findUnique({
      where: { id }
    });
    
    if (!challenge) {
      return NextResponse.json({ error: 'Challenge not found' }, { status: 404 });
    }
    
    if (challenge.creatorId !== auth.userId) {
      return NextResponse.json({ 
        error: 'Only the challenge creator can update contract details' 
      }, { status: 403 });
    }
    
    // Update the challenge with blockchain details
    const updatedChallenge = await prisma.challenge.update({
      where: { id },
      data: {
        contractAddress,
        contractChain: contractChain || 'polygon', // Default to polygon if not specified
      }
    });
    
    // Create a transaction record for the contract registration
    await prisma.transaction.create({
      data: {
        userId: auth.userId,
        transactionType: 'CONTRACT_REGISTRATION',
        amount: 0, // No amount for registration
        currency: 'MATIC', // Gas fee currency
        txHash: transactionHash,
        status: 'COMPLETED',
        completedAt: new Date()
      }
    });
    
    return NextResponse.json(updatedChallenge);
  } catch (error) {
    console.error('Error updating challenge contract details:', error);
    return NextResponse.json({ 
      error: 'Failed to update contract details', 
      details: error.message 
    }, { status: 500 });
  }
}

================
File: app/api/challenges/[id]/route.js
================
// app/api/challenges/[id]/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request, { params }) {
  try {
    const { id } = params;
    
    if (!id) {
      return NextResponse.json({ error: 'Challenge ID is required' }, { status: 400 });
    }
    
    // Verify authentication (optional - can show challenge details to non-authenticated users)
    const auth = await verifyAuth();
    const isAuthenticated = auth.success;
    
    // Fetch challenge details
    const challenge = await prisma.challenge.findUnique({
      where: { id },
      include: {
        creator: {
          select: {
            id: true,
            username: true
          }
        },
        _count: {
          select: {
            participants: true
          }
        }
      }
    });
    
    if (!challenge) {
      return NextResponse.json({ error: 'Challenge not found' }, { status: 404 });
    }
    
    // If authenticated, check if user is already participating
    let userParticipation = null;
    
    if (isAuthenticated) {
      userParticipation = await prisma.userChallenge.findUnique({
        where: {
          userId_challengeId: {
            userId: auth.userId,
            challengeId: id
          }
        }
      });
    }
    
    // Check if the challenge has reached max participants
    const isAtCapacity = 
      challenge.maxParticipants && 
      challenge._count.participants >= challenge.maxParticipants;
    
    // Format response
    const response = {
      ...challenge,
      participantCount: challenge._count.participants,
      isAtCapacity,
      isParticipating: Boolean(userParticipation),
      creatorName: challenge.creator.username,
      
      // Add additional computed properties
      formattedStartDate: challenge.createdAt.toLocaleDateString(),
      formattedEndDate: new Date(
        new Date(challenge.createdAt).setDate(
          new Date(challenge.createdAt).getDate() + challenge.durationDays
        )
      ).toLocaleDateString(),
      
      // Calculate potential reward
      potentialReward: challenge.stakeAmount * (1 + (challenge.yieldPercentage / 100)),
      
      // Remove sensitive or unnecessary data
      _count: undefined
    };
    
    return NextResponse.json(response);
  } catch (error) {
    console.error('Error fetching challenge details:', error);
    return NextResponse.json(
      { error: 'Failed to fetch challenge details', details: error.message },
      { status: 500 }
    );
  }
}

================
File: app/api/challenges/complete/route.js
================
// app/api/challenges/complete/route.js - Enhanced version
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';
import { processRewardDistribution } from '@/lib/web3/staking';

const prisma = new PrismaClient();

export async function POST(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    const { userChallengeId } = body;
    
    if (!userChallengeId) {
      return NextResponse.json({ error: 'User challenge ID is required' }, { status: 400 });
    }
    // Get user challenge
const userChallenge = await prisma.userChallenge.findUnique({
  where: { 
    id: userChallengeId,
    userId: auth.userId, // Ensure the challenge belongs to the authenticated user
    status: 'ACTIVE'
  },
  include: {
    challenge: true,
    dailyProgress: true
  }
});

if (!userChallenge) {
  return NextResponse.json({ error: 'Challenge not found or already completed' }, { status: 404 });
}

// Log the challenge completion request for audit purposes
console.log(`Challenge completion request: ${userChallengeId} by user ${auth.userId}`);

// Check completion criteria
const totalDays = userChallenge.challenge.durationDays;
const completedDays = userChallenge.dailyProgress.filter(p => p.completed).length;

// For simplicity, we'll say a challenge is complete if the user has completed at least 80% of the days
const completionThreshold = Math.floor(totalDays * 0.8);

if (completedDays < completionThreshold) {
  return NextResponse.json({ 
    error: `Challenge not yet complete. You've completed ${completedDays} days out of ${totalDays} required.`,
    completedDays,
    totalDays,
    completionThreshold
  }, { status: 400 });
}

// Calculate reward amount
const rewardAmount = userChallenge.stakedAmount * (1 + userChallenge.challenge.yieldPercentage / 100);

// Set the transaction status to pending while we process blockchain transaction
await prisma.userChallenge.update({
  where: { id: userChallengeId },
  data: {
    status: 'PENDING_COMPLETION'
  }
});

// Handle blockchain transaction
const transaction = await processRewardDistribution(
  userChallengeId,
  auth.userId,
  auth.walletAddress,
  rewardAmount
);

if (!transaction.success) {
  // Record the failure but allow retry
  await prisma.transaction.create({
    data: {
      userId: auth.userId,
      transactionType: 'REWARD',
      amount: rewardAmount,
      currency: 'USDC',
      txHash: null,
      status: 'FAILED',
      createdAt: new Date()
    }
  });
  
  return NextResponse.json({ 
    error: transaction.error || 'Transaction failed',
    retryable: true 
  }, { status: 500 });
}

// Update user challenge status
const updatedChallenge = await prisma.userChallenge.update({
  where: { id: userChallengeId },
  data: {
    status: 'COMPLETED',
    completionTxHash: transaction.transactionHash,
    progressPercentage: 100
  }
});

// Create transaction record
await prisma.transaction.create({
  data: {
    userId: auth.userId,
    transactionType: 'REWARD',
    amount: rewardAmount,
    currency: 'USDC',
    txHash: transaction.transactionHash,
    status: 'COMPLETED',
    completedAt: new Date()
  }
});

// Create achievement if this is the user's first completed challenge
const completedChallengesCount = await prisma.userChallenge.count({
  where: {
    userId: auth.userId,
    status: 'COMPLETED'
  }
});

if (completedChallengesCount === 1) {
  // Find the "First Challenge Completed" achievement
  const achievement = await prisma.achievement.findFirst({
    where: { achievementType: 'CHALLENGE_COMPLETED', threshold: 1 }
  });
  
  if (achievement) {
    await prisma.userAchievement.create({
      data: {
        userId: auth.userId,
        achievementId: achievement.id
      }
    });
  }
}

// Create notification
await prisma.notification.create({
  data: {
    userId: auth.userId,
    type: 'CHALLENGE_COMPLETED',
    title: 'Challenge Completed!',
    message: `Congratulations! You've completed the "${userChallenge.challenge.title}" challenge and earned ${rewardAmount.toFixed(2)} USDC.`,
    read: false
  }
});

return NextResponse.json({
  success: true,
  challenge: updatedChallenge,
  reward: rewardAmount,
  transactionHash: transaction.transactionHash
});
} catch (error) {
  console.error('Error completing challenge:', error);
  return NextResponse.json({ error: 'Failed to complete challenge' }, { status: 500 });
}
}

================
File: app/api/challenges/create/route.js
================
// app/api/challenges/create/route.js - Modified version
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';
import { nanoid } from 'nanoid';

const prisma = new PrismaClient();

export async function POST(request) {
  try {
    // Verify authentication
    const auth = await verifyAuth();
    
    if (!auth.success) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const body = await request.json();
    
    // Validate request body
    const requiredFields = [
      'title', 
      'languageCode', 
      'proficiencyLevel', 
      'durationDays', 
      'dailyRequirement', 
      'stakeAmount'
    ];
    
    const missingFields = requiredFields.filter(field => !body[field]);
    
    if (missingFields.length > 0) {
      return NextResponse.json({ 
        error: `Missing required fields: ${missingFields.join(', ')}` 
      }, { status: 400 });
    }
    
    // Validate numerical fields
    const numericFields = [
      { name: 'durationDays', min: 7, max: 365 },
      { name: 'dailyRequirement', min: 5, max: 120 },
      { name: 'stakeAmount', min: 10, max: 1000 },
      { name: 'yieldPercentage', min: 0, max: 20 }
    ];
    
    for (const field of numericFields) {
      const value = parseFloat(body[field.name]);
      
      if (isNaN(value)) {
        return NextResponse.json({ 
          error: `Invalid value for ${field.name}: must be a number` 
        }, { status: 400 });
      }
      
      if (value < field.min || value > field.max) {
        return NextResponse.json({ 
          error: `${field.name} must be between ${field.min} and ${field.max}` 
        }, { status: 400 });
      }
    }
    
    // Generate a random invite code if this is a private challenge but no code provided
    let inviteCode = body.inviteCode;
    if (body.maxParticipants && !inviteCode) {
      inviteCode = nanoid(8);
    }
    
    // Create the challenge
    const challenge = await prisma.challenge.create({
      data: {
        title: body.title,
        description: body.description || '',
        languageCode: body.languageCode,
        proficiencyLevel: body.proficiencyLevel,
        durationDays: parseInt(body.durationDays),
        dailyRequirement: parseInt(body.dailyRequirement),
        stakeAmount: parseFloat(body.stakeAmount),
        yieldPercentage: parseFloat(body.yieldPercentage || 5),
        isHardcore: Boolean(body.isHardcore),
        maxParticipants: body.maxParticipants ? parseInt(body.maxParticipants) : null,
        inviteCode: inviteCode,
        creatorId: auth.userId,
        isActive: true,
        
        // Add blockchain-related fields if provided
        contractAddress: body.contractAddress || null,
        contractChain: body.contractChain || null
      }
    });
    
    // If blockchain transaction information is provided, create a transaction record
    if (body.transactionHash) {
      await prisma.transaction.create({
        data: {
          userId: auth.userId,
          transactionType: 'CONTRACT_REGISTRATION',
          amount: 0, // No amount for registration
          currency: 'MATIC', // Gas fee currency
          txHash: body.transactionHash,
          status: 'COMPLETED',
          completedAt: new Date()
        }
      });
    }
    
    // Automatically join the creator to their own challenge if specified
    if (body.autoJoin) {
      const startDate = new Date();
      const endDate = new Date();
      endDate.setDate(endDate.getDate() + parseInt(body.durationDays));
      
      await prisma.userChallenge.create({
        data: {
          userId: auth.userId,
          challengeId: challenge.id,
          startDate: startDate,
          endDate: endDate,
          stakedAmount: parseFloat(body.stakeAmount),
          currentStreak: 0,
          longestStreak: 0,
          progressPercentage: 0,
          status: 'ACTIVE',
          stakeTxHash: body.stakeTxHash || null
        }
      });
    }
    
    // Create notification for successful challenge creation
    await prisma.notification.create({
      data: {
        userId: auth.userId,
        type: 'CHALLENGE_CREATED',
        title: 'Challenge Created',
        message: `You've successfully created the "${challenge.title}" challenge.`,
        read: false
      }
    });
    
    return NextResponse.json(challenge, { status: 201 });
  } catch (error) {
    console.error('Error creating challenge:', error);
    return NextResponse.json({ 
      error: 'Failed to create challenge', 
      details: error.message 
    }, { status: 500 });
  }
}

================
File: app/api/challenges/daily-progress/route.js
================
// app/api/challenges/daily-progress/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    // Get userChallengeId from query params
    const { searchParams } = new URL(request.url);
    const userChallengeId = searchParams.get('userChallengeId');
    
    if (!userChallengeId) {
      return NextResponse.json({ error: 'User challenge ID is required' }, { status: 400 });
    }
    
    // Verify the user challenge belongs to the authenticated user
    const userChallenge = await prisma.userChallenge.findFirst({
      where: {
        id: userChallengeId,
        userId: auth.userId
      }
    });
    
    if (!userChallenge) {
      return NextResponse.json({ error: 'Challenge not found' }, { status: 404 });
    }
    
    // Get today's date (reset to midnight)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Find today's progress if it exists
    const todayProgress = await prisma.dailyProgress.findUnique({
      where: {
        userChallengeId_date: {
          userChallengeId,
          date: today
        }
      }
    });
    
    if (!todayProgress) {
      return NextResponse.json({
        minutesPracticed: 0,
        completed: false,
        date: today.toISOString()
      });
    }
    
    // Return today's progress
    return NextResponse.json({
      minutesPracticed: todayProgress.minutesPracticed,
      completed: todayProgress.completed,
      date: todayProgress.date.toISOString()
    });
  } catch (error) {
    console.error('Error getting daily progress:', error);
    return NextResponse.json({ error: 'Failed to get daily progress' }, { status: 500 });
  }
}

================
File: app/api/challenges/join/route.js
================
// app/api/challenges/join/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';
import { processStaking } from '@/lib/web3/staking';

const prisma = new PrismaClient();

export async function POST(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    const { challengeId, transactionHash } = body;
    
    if (!challengeId || !transactionHash) {
      return NextResponse.json({ error: 'Challenge ID and transaction hash are required' }, { status: 400 });
    }
    
    // Verify the challenge exists and is active
    const challenge = await prisma.challenge.findUnique({
      where: { id: challengeId, isActive: true }
    });
    
    if (!challenge) {
      return NextResponse.json({ error: 'Challenge not found or inactive' }, { status: 404 });
    }
    
    // Check if user is already participating
    const existingParticipation = await prisma.userChallenge.findUnique({
      where: {
        userId_challengeId: {
          userId: auth.userId,
          challengeId: challengeId
        }
      }
    });
    
    if (existingParticipation) {
      return NextResponse.json({ error: 'User is already participating in this challenge' }, { status: 400 });
    }
    
    // Verify transaction on the blockchain
    const stakingVerified = await processStaking(transactionHash, challenge.stakeAmount, auth.walletAddress);
    
    if (!stakingVerified.success) {
      return NextResponse.json({ error: stakingVerified.error }, { status: 400 });
    }
    
    // Calculate end date
    const startDate = new Date();
    const endDate = new Date();
    endDate.setDate(endDate.getDate() + challenge.durationDays);
    
    // Create user challenge participation
    const userChallenge = await prisma.userChallenge.create({
      data: {
        userId: auth.userId,
        challengeId: challengeId,
        startDate: startDate,
        endDate: endDate,
        stakedAmount: challenge.stakeAmount,
        stakeTxHash: transactionHash,
        currentStreak: 0,
        longestStreak: 0,
        progressPercentage: 0,
        status: 'ACTIVE'
      }
    });
    
    return NextResponse.json(userChallenge);
  } catch (error) {
    console.error('Error joining challenge:', error);
    return NextResponse.json({ error: 'Failed to join challenge' }, { status: 500 });
  }
}

================
File: app/api/challenges/practice-info/route.js
================
// app/api/challenges/practice-info/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    // Get userChallengeId from query params
    const { searchParams } = new URL(request.url);
    const userChallengeId = searchParams.get('userChallengeId');
    
    if (!userChallengeId) {
      return NextResponse.json({ error: 'User challenge ID is required' }, { status: 400 });
    }
    
    // Verify the user challenge belongs to the authenticated user
    const userChallenge = await prisma.userChallenge.findFirst({
      where: {
        id: userChallengeId,
        userId: auth.userId,
        status: 'ACTIVE'
      },
      include: {
        challenge: true
      }
    });
    
    if (!userChallenge) {
      return NextResponse.json({ error: 'Challenge not found or not active' }, { status: 404 });
    }
    
    // Get today's date (reset to midnight)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Find today's progress if it exists
    const todayProgress = await prisma.dailyProgress.findUnique({
      where: {
        userChallengeId_date: {
          userChallengeId,
          date: today
        }
      }
    });
    
    // Return practice info
    return NextResponse.json({
      dailyRequirement: userChallenge.challenge.dailyRequirement,
      todayProgress: todayProgress?.minutesPracticed || 0,
      todayCompleted: todayProgress?.completed || false,
      currentStreak: userChallenge.currentStreak,
      longestStreak: userChallenge.longestStreak,
      progressPercentage: userChallenge.progressPercentage,
      language: {
        code: userChallenge.challenge.languageCode,
        level: userChallenge.challenge.proficiencyLevel
      }
    });
  } catch (error) {
    console.error('Error getting practice info:', error);
    return NextResponse.json({ error: 'Failed to get practice info' }, { status: 500 });
  }
}

================
File: app/api/challenges/update-progress/route.js
================
// app/api/challenges/update-progress/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function POST(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    const { userChallengeId, minutes, isSessionEnd, conversationId } = body;
    
    if (!userChallengeId || !minutes) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }
    
    // Verify the user challenge belongs to the authenticated user
    const userChallenge = await prisma.userChallenge.findFirst({
      where: {
        id: userChallengeId,
        userId: auth.userId,
        status: 'ACTIVE'
      },
      include: {
        challenge: true
      }
    });
    
    if (!userChallenge) {
      return NextResponse.json({ error: 'Challenge not found or not active' }, { status: 404 });
    }
    
    // Get today's date (reset to midnight)
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Find or create daily progress record
    let dailyProgress = await prisma.dailyProgress.findUnique({
      where: {
        userChallengeId_date: {
          userChallengeId,
          date: today
        }
      }
    });
    
    if (dailyProgress) {
      // Update existing record
      dailyProgress = await prisma.dailyProgress.update({
        where: { id: dailyProgress.id },
        data: {
          minutesPracticed: dailyProgress.minutesPracticed + minutes,
          completed: (dailyProgress.minutesPracticed + minutes) >= userChallenge.challenge.dailyRequirement
        }
      });
    } else {
      // Create new record
      dailyProgress = await prisma.dailyProgress.create({
        data: {
          userChallengeId,
          date: today,
          minutesPracticed: minutes,
          completed: minutes >= userChallenge.challenge.dailyRequirement
        }
      });
    }
    
    // Update user streak
    await updateUserStreak(userChallengeId);
    
    // Update overall progress percentage
    await updateOverallProgress(userChallengeId);
    
    // If this is the end of a session and we have a conversationId,
    // associate the conversation with this progress
    if (isSessionEnd && conversationId) {
      await prisma.aIConversation.update({
        where: { id: conversationId },
        data: {
          endedAt: new Date(),
          durationMinutes: minutes
        }
      });
    }
    
    return NextResponse.json({
      success: true,
      minutesPracticed: dailyProgress.minutesPracticed,
      completed: dailyProgress.completed
    });
  } catch (error) {
    console.error('Error updating progress:', error);
    return NextResponse.json({ error: 'Failed to update progress' }, { status: 500 });
  }
}

// Helper function to update user streak
async function updateUserStreak(userChallengeId) {
  try {
    // Get the user challenge record
    const userChallenge = await prisma.userChallenge.findUnique({
      where: { id: userChallengeId }
    });
    
    if (!userChallenge) {
      console.error('User challenge not found');
      return;
    }
    
    // Get daily progress records ordered by date descending
    const progressRecords = await prisma.dailyProgress.findMany({
      where: { userChallengeId },
      orderBy: { date: 'desc' },
      select: { date: true, completed: true }
    });
    
    // If no records, streak is 0
    if (progressRecords.length === 0) {
      await prisma.userChallenge.update({
        where: { id: userChallengeId },
        data: { currentStreak: 0 }
      });
      return;
    }
    
    // Calculate current streak
    let currentStreak = 0;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Check if today's record exists and was completed
    const todayRecord = progressRecords.find(record => {
      const recordDate = new Date(record.date);
      recordDate.setHours(0, 0, 0, 0);
      return recordDate.getTime() === today.getTime() && record.completed;
    });
    
    if (todayRecord) {
      currentStreak = 1;
      
      // Check previous days
      let prevDate = new Date(today);
      prevDate.setDate(prevDate.getDate() - 1);
      
      let consecutiveDays = true;
      while (consecutiveDays) {
        const prevDayRecord = progressRecords.find(record => {
          const recordDate = new Date(record.date);
          recordDate.setHours(0, 0, 0, 0);
          return recordDate.getTime() === prevDate.getTime() && record.completed;
        });
        
        if (prevDayRecord) {
          currentStreak++;
          prevDate.setDate(prevDate.getDate() - 1);
        } else {
          consecutiveDays = false;
        }
      }
    }
    
    // Update current streak
    await prisma.userChallenge.update({
      where: { id: userChallengeId },
      data: { 
        currentStreak,
        // Update longest streak if current > longest
        longestStreak: currentStreak > userChallenge.longestStreak 
          ? currentStreak 
          : userChallenge.longestStreak
      }
    });
  } catch (error) {
    console.error('Error updating user streak:', error);
  }
}

// Helper function to update overall progress
async function updateOverallProgress(userChallengeId) {
  try {
    // Get the user challenge and related challenge data
    const userChallenge = await prisma.userChallenge.findUnique({
      where: { id: userChallengeId },
      include: { 
        challenge: true,
        dailyProgress: true
      }
    });
    
    if (!userChallenge) {
      console.error('User challenge not found');
      return;
    }
    
    // Calculate overall progress percentage
    // Method: (completed days / total challenge days) * 100
    const totalDays = userChallenge.challenge.durationDays;
    const completedDays = userChallenge.dailyProgress.filter(p => p.completed).length;
    
    // Calculate days elapsed since challenge start
    const startDate = new Date(userChallenge.startDate);
    const today = new Date();
    const daysDiff = Math.floor((today - startDate) / (1000 * 60 * 60 * 24)) + 1; // +1 to include start day
    
    // Calculate expected progress at this point (can't exceed 100%)
    const expectedProgress = Math.min(daysDiff / totalDays, 1);
    
    // Calculate actual progress (can't exceed 100%)
    const actualProgress = Math.min(completedDays / totalDays, 1);
    
    // Calculate overall percentage
    const progressPercentage = Math.round(actualProgress * 100);
    
    // Update user challenge progress
    await prisma.userChallenge.update({
      where: { id: userChallengeId },
      data: { progressPercentage }
    });
  } catch (error) {
    console.error('Error updating overall progress:', error);
  }
}

================
File: app/api/challenges/user/route.js
================
// app/api/challenges/user/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    // Get status from query params
    const { searchParams } = new URL(request.url);
    const status = searchParams.get('status') || 'ACTIVE';
    
    // Fetch user challenges based on status
    const userChallenges = await prisma.userChallenge.findMany({
      where: {
        userId: auth.userId,
        status: status
      },
      include: {
        challenge: true
      },
      orderBy: {
        endDate: 'asc'
      }
    });
    
    return NextResponse.json(userChallenges);
  } catch (error) {
    console.error('Error fetching user challenges:', error);
    return NextResponse.json({ error: 'Failed to fetch challenges' }, { status: 500 });
  }
}

================
File: app/api/conversation/evaluate/route.js
================
// app/api/conversation/evaluate/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';
import OpenAI from 'openai';

const prisma = new PrismaClient();
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    const { conversationId } = body;
    
    if (!conversationId) {
      return NextResponse.json({ error: 'Conversation ID is required' }, { status: 400 });
    }
    
    // Get conversation and messages
    const conversation = await prisma.aIConversation.findUnique({
      where: { 
        id: conversationId,
        userId: auth.userId
      },
      include: {
        messages: {
          orderBy: { timestamp: 'asc' },
        },
      },
    });
    
    if (!conversation) {
      return NextResponse.json({ error: 'Conversation not found' }, { status: 404 });
    }
    
    // Prepare conversation transcript
    const transcript = conversation.messages.map(msg => 
      `${msg.sender === 'USER' ? 'User' : 'AI'}: ${msg.content}`
    ).join('\n\n');
    
    // Check if there are enough user messages for evaluation
    const userMessages = conversation.messages.filter(msg => msg.sender === 'USER');
    if (userMessages.length < 5) {
      return NextResponse.json({ error: 'Not enough conversation data for evaluation' }, { status: 400 });
    }
    
    // Get language proficiency level
    const userLanguage = await prisma.userLanguage.findUnique({
      where: {
        userId_languageCode: {
          userId: auth.userId,
          languageCode: conversation.languageCode,
        },
      },
    });
    
    const proficiencyLevel = userLanguage?.proficiencyLevel || 'BEGINNER';
    
    // Create evaluation prompt
    const evaluationPrompt = `You are a language learning evaluation expert for ${getLanguageName(conversation.languageCode)}.
    Please evaluate the user's language skills based on the following conversation.
    The user's current proficiency level is ${proficiencyLevel}.
    
    Provide scores for the following aspects on a scale of 0-100:
    1. Grammar accuracy
    2. Vocabulary usage
    3. Fluency and natural expression
    4. Pronunciation (based on written indicators)
    
    Also provide:
    - Specific strengths demonstrated
    - Areas for improvement
    - Overall evaluation
    - Estimated vocabulary size based on words used
    - Recommended next learning focus
    
    Format your response as JSON with the following structure:
    {
      "grammarScore": number,
      "vocabularyScore": number,
      "fluencyScore": number,
      "pronunciationScore": number,
      "overallScore": number,
      "strengths": "text",
      "improvements": "text",
      "evaluation": "text",
      "estimatedVocabularySize": number,
      "recommendedFocus": "text"
    }
    
    Conversation transcript:
    ${transcript}`;
    
    // Generate evaluation using OpenAI
    const evaluationResponse = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        { role: "system", content: evaluationPrompt }
      ],
      temperature: 0.3,
      response_format: { type: "json_object" },
    });
    
    // Parse evaluation
    const evaluationContent = evaluationResponse.choices[0].message.content;
    const evaluation = JSON.parse(evaluationContent);
    
    // Store evaluation in database
    const conversationEvaluation = await prisma.conversationEvaluation.create({
      data: {
        conversationId: conversation.id,
        grammarScore: evaluation.grammarScore,
        vocabularyScore: evaluation.vocabularyScore,
        pronunciationScore: evaluation.pronunciationScore,
        fluencyScore: evaluation.fluencyScore,
        overallScore: evaluation.overallScore,
        feedback: JSON.stringify({
          strengths: evaluation.strengths,
          improvements: evaluation.improvements,
          evaluation: evaluation.evaluation,
          estimatedVocabularySize: evaluation.estimatedVocabularySize,
          recommendedFocus: evaluation.recommendedFocus
        })
      }
    });
    
    // Update user progress record
    await prisma.progressRecord.create({
      data: {
        userId: auth.userId,
        languageCode: conversation.languageCode,
        recordDate: new Date(),
        vocabularySize: evaluation.estimatedVocabularySize,
        grammarAccuracy: evaluation.grammarScore,
        speakingFluency: evaluation.fluencyScore,
        listeningComprehension: evaluation.pronunciationScore * 0.8, // Estimate based on pronunciation
        overallLevel: updateProficiencyLevel(proficiencyLevel, evaluation.overallScore)
      }
    });
    
    // Check if user should level up
    if (shouldLevelUp(proficiencyLevel, evaluation.overallScore)) {
      await prisma.userLanguage.update({
        where: {
          userId_languageCode: {
            userId: auth.userId,
            languageCode: conversation.languageCode,
          },
        },
        data: {
          proficiencyLevel: getNextLevel(proficiencyLevel)
        }
      });
      
      // Create notification for level up
      await prisma.notification.create({
        data: {
          userId: auth.userId,
          type: 'ACHIEVEMENT_EARNED',
          title: 'Level Up!',
          message: `Congratulations! You've leveled up to ${getNextLevelName(proficiencyLevel)} in ${getLanguageName(conversation.languageCode)}.`,
          read: false
        }
      });
    }
    
    return NextResponse.json({
      evaluation: {
        ...evaluation,
        id: conversationEvaluation.id
      }
    });
  } catch (error) {
    console.error('Error evaluating conversation:', error);
    return NextResponse.json({ error: 'Failed to evaluate conversation' }, { status: 500 });
  }
}

// Helper function to get language name
function getLanguageName(code) {
  const languages = {
    'en': 'English',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'it': 'Italian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'ru': 'Russian',
    'pt': 'Portuguese',
    'ar': 'Arabic',
    'hi': 'Hindi'
  };
  
  return languages[code] || code;
}

// Helper function to check if user should level up
function shouldLevelUp(currentLevel, overallScore) {
  const thresholds = {
    'BEGINNER': 75,
    'ELEMENTARY': 80,
    'INTERMEDIATE': 85,
    'ADVANCED': 90
  };
  
  return thresholds[currentLevel] && overallScore >= thresholds[currentLevel];
}

// Helper function to get next proficiency level
function getNextLevel(currentLevel) {
  const levels = {
    'BEGINNER': 'ELEMENTARY',
    'ELEMENTARY': 'INTERMEDIATE',
    'INTERMEDIATE': 'ADVANCED',
    'ADVANCED': 'FLUENT'
  };
  
  return levels[currentLevel] || currentLevel;
}

// Helper function to get next level name
function getNextLevelName(currentLevel) {
  const levels = {
    'BEGINNER': 'Elementary',
    'ELEMENTARY': 'Intermediate',
    'INTERMEDIATE': 'Advanced',
    'ADVANCED': 'Fluent'
  };
  
  return levels[currentLevel] || 'Next Level';
}

// Helper function to update proficiency level based on score
function updateProficiencyLevel(currentLevel, score) {
  // Don't decrease level based on one evaluation
  // Only return next level if score exceeds threshold
  if (shouldLevelUp(currentLevel, score)) {
    return getNextLevel(currentLevel);
  }
  
  return currentLevel;
}

================
File: app/api/conversation/route.js
================
// app/api/conversation/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';
import OpenAI from 'openai';

const prisma = new PrismaClient();
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export async function POST(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    const { message, conversationId, languageCode, userChallengeId } = body;
    
    if (!message) {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 });
    }
    
    // Get or create conversation
    let conversation;
    let messages = [];
    
    if (conversationId) {
      conversation = await prisma.aIConversation.findUnique({
        where: { id: conversationId },
        include: {
          messages: {
            orderBy: { timestamp: 'asc' },
          },
        },
      });
      
      if (!conversation) {
        return NextResponse.json({ error: 'Conversation not found' }, { status: 404 });
      }
      
      messages = conversation.messages;
    } else {
      // Create new conversation
      conversation = await prisma.aIConversation.create({
        data: {
          userId: auth.userId,
          languageCode: languageCode || 'en',
          avatarType: 'default',
          userChallengeId: userChallengeId
        }
      });
    }
    
    // Save user message
    const userMessage = await prisma.conversationMessage.create({
      data: {
        conversationId: conversation.id,
        sender: 'USER',
        content: message,
      },
    });
    
    // Format previous messages for OpenAI
    const previousMessages = messages.map(msg => ({
      role: msg.sender === 'USER' ? 'user' : 'assistant',
      content: msg.content,
    }));
    
    // Get user language proficiency
    const userLanguage = await prisma.userLanguage.findUnique({
      where: {
        userId_languageCode: {
          userId: auth.userId,
          languageCode: conversation.languageCode,
        },
      },
    });
    
    const proficiencyLevel = userLanguage?.proficiencyLevel || 'BEGINNER';
    
    // Create system prompt based on language and proficiency
    const systemPrompt = `You are a helpful language tutor for ${getLanguageName(conversation.languageCode)} at ${proficiencyLevel.toLowerCase()} level.
    - Respond primarily in ${getLanguageName(conversation.languageCode)} with English translations when appropriate.
    - Adjust your language complexity to match ${proficiencyLevel.toLowerCase()} level.
    - Provide gentle corrections for grammar or vocabulary mistakes.
    - Be encouraging and supportive.
    - For beginner levels, use simple sentences and basic vocabulary.
    - For intermediate levels, introduce more complex grammar and vocabulary.
    - For advanced levels, use natural, native-like language.
    - When the user makes a mistake, provide the correction in [brackets].
    - Each response should end with a question to keep the conversation going.`;
    
    // Generate AI response
    const aiResponse = await openai.chat.completions.create({
      model: "gpt-4",
      messages: [
        { role: "system", content: systemPrompt },
        ...previousMessages,
        { role: "user", content: message }
      ],
      temperature: 0.7,
      max_tokens: 300,
    });
    
    const aiContent = aiResponse.choices[0].message.content;
    
    // Save AI response
    const aiMessageRecord = await prisma.conversationMessage.create({
      data: {
        conversationId: conversation.id,
        sender: 'AI',
        content: aiContent,
      },
    });
    
    // Update practice minutes for challenge if applicable
    if (userChallengeId) {
      await updateChallengeProgress(userChallengeId, 1); // Add 1 minute of practice
    }
    
    return NextResponse.json({
      id: aiMessageRecord.id,
      content: aiContent,
      conversationId: conversation.id
    });
  } catch (error) {
    console.error('Error in conversation:', error);
    return NextResponse.json({ error: 'Failed to process conversation' }, { status: 500 });
  }
}

// Helper function to get language name
function getLanguageName(code) {
  const languages = {
    'en': 'English',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'it': 'Italian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'ru': 'Russian',
    'pt': 'Portuguese',
    'ar': 'Arabic',
    'hi': 'Hindi'
  };
  
  return languages[code] || code;
}

// Helper function to update challenge progress
async function updateChallengeProgress(userChallengeId, minutes) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  
  try {
    // Check if there's already a daily progress record for today
    const existingProgress = await prisma.dailyProgress.findUnique({
      where: {
        userChallengeId_date: {
          userChallengeId: userChallengeId,
          date: today
        }
      }
    });
    
    if (existingProgress) {
      // Update existing record
      await prisma.dailyProgress.update({
        where: {
          id: existingProgress.id
        },
        data: {
          minutesPracticed: existingProgress.minutesPracticed + minutes,
          completed: (existingProgress.minutesPracticed + minutes) >= 
            (await getUserChallengeRequirement(userChallengeId))
        }
      });
    } else {
      // Create new record
      const dailyRequirement = await getUserChallengeRequirement(userChallengeId);
      
      await prisma.dailyProgress.create({
        data: {
          userChallengeId: userChallengeId,
          date: today,
          minutesPracticed: minutes,
          completed: minutes >= dailyRequirement
        }
      });
      
      // Update streak
      await updateUserStreak(userChallengeId);
    }
    
    // Update overall progress percentage
    await updateOverallProgress(userChallengeId);
    
  } catch (error) {
    console.error('Error updating challenge progress:', error);
  }
}

async function getUserChallengeRequirement(userChallengeId) {
  const userChallenge = await prisma.userChallenge.findUnique({
    where: { id: userChallengeId },
    include: { challenge: true }
  });
  
  return userChallenge?.challenge?.dailyRequirement || 20; // Default to 20 minutes
}
async function updateUserStreak(userChallengeId) {
    try {
      // Get the user challenge record
      const userChallenge = await prisma.userChallenge.findUnique({
        where: { id: userChallengeId }
      });
      
      if (!userChallenge) {
        console.error('User challenge not found');
        return;
      }
      
      // Get daily progress records ordered by date descending
      const progressRecords = await prisma.dailyProgress.findMany({
        where: { userChallengeId },
        orderBy: { date: 'desc' },
        select: { date: true, completed: true }
      });
      
      // If no records, streak is 0
      if (progressRecords.length === 0) {
        await prisma.userChallenge.update({
          where: { id: userChallengeId },
          data: { currentStreak: 0 }
        });
        return;
      }
      
      // Calculate current streak
      let currentStreak = 0;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Check if today's record exists and was completed
      const todayRecord = progressRecords.find(record => {
        const recordDate = new Date(record.date);
        recordDate.setHours(0, 0, 0, 0);
        return recordDate.getTime() === today.getTime() && record.completed;
      });
      
      if (todayRecord) {
        currentStreak = 1;
        
        // Check previous days
        let prevDate = new Date(today);
        prevDate.setDate(prevDate.getDate() - 1);
        
        let consecutiveDays = true;
        while (consecutiveDays) {
          const prevDayRecord = progressRecords.find(record => {
            const recordDate = new Date(record.date);
            recordDate.setHours(0, 0, 0, 0);
            return recordDate.getTime() === prevDate.getTime() && record.completed;
          });
          
          if (prevDayRecord) {
            currentStreak++;
            prevDate.setDate(prevDate.getDate() - 1);
          } else {
            consecutiveDays = false;
          }
        }
      }
      
      // Update current streak
      await prisma.userChallenge.update({
        where: { id: userChallengeId },
        data: { 
          currentStreak,
          // Update longest streak if current > longest
          longestStreak: currentStreak > userChallenge.longestStreak 
            ? currentStreak 
            : userChallenge.longestStreak
        }
      });
    } catch (error) {
      console.error('Error updating user streak:', error);
    }
  }
  
  async function updateOverallProgress(userChallengeId) {
    try {
      // Get the user challenge and related challenge data
      const userChallenge = await prisma.userChallenge.findUnique({
        where: { id: userChallengeId },
        include: { 
          challenge: true,
          dailyProgress: true
        }
      });
      
      if (!userChallenge) {
        console.error('User challenge not found');
        return;
      }
      
      // Calculate overall progress percentage
      // Method: (completed days / total challenge days) * 100
      const totalDays = userChallenge.challenge.durationDays;
      const completedDays = userChallenge.dailyProgress.filter(p => p.completed).length;
      
      // Calculate days elapsed since challenge start
      const startDate = new Date(userChallenge.startDate);
      const today = new Date();
      const daysDiff = Math.floor((today - startDate) / (1000 * 60 * 60 * 24)) + 1; // +1 to include start day
      
      // Calculate expected progress at this point (can't exceed 100%)
      const expectedProgress = Math.min(daysDiff / totalDays, 1);
      
      // Calculate actual progress (can't exceed 100%)
      const actualProgress = Math.min(completedDays / totalDays, 1);
      
      // Calculate overall percentage
      const progressPercentage = Math.round(actualProgress * 100);
      
      // Update user challenge progress
      await prisma.userChallenge.update({
        where: { id: userChallengeId },
        data: { progressPercentage }
      });
      
      // If challenge is completed, check if we need to update status
      if (progressPercentage >= 100 && userChallenge.status === 'ACTIVE') {
        // Optional: automatically complete the challenge
        // You might want this to be manual instead
        // await prisma.userChallenge.update({
        //   where: { id: userChallengeId },
        //   data: { status: 'COMPLETED' }
        // });
      }
    } catch (error) {
      console.error('Error updating overall progress:', error);
    }
  }

================
File: app/api/users/activity/route.js
================
// app/api/users/activity/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const period = searchParams.get('period') || 'week'; // 'week', 'month'
    
    // Calculate date range
    const endDate = new Date();
    const startDate = new Date();
    
    if (period === 'week') {
      startDate.setDate(startDate.getDate() - 7);
    } else {
      startDate.setMonth(startDate.getMonth() - 1);
    }
    
    // Get practice minutes
    const practiceMinutes = await prisma.dailyProgress.findMany({
      where: {
        userChallenge: {
          userId: auth.userId
        },
        date: {
          gte: startDate,
          lte: endDate
        }
      },
      select: {
        date: true,
        minutesPracticed: true,
        userChallenge: {
          select: {
            challenge: {
              select: {
                languageCode: true
              }
            }
          }
        }
      }
    });
    
    // Aggregate practice minutes by day and language
    const practiceByDay = {};
    
    practiceMinutes.forEach(record => {
      const lang = record.userChallenge.challenge.languageCode;
      const dateStr = record.date.toISOString().split('T')[0]; // YYYY-MM-DD
      
      if (!practiceByDay[dateStr]) {
        practiceByDay[dateStr] = {};
      }
      
      if (!practiceByDay[dateStr][lang]) {
        practiceByDay[dateStr][lang] = 0;
      }
      
      practiceByDay[dateStr][lang] += record.minutesPracticed;
    });
    
    return NextResponse.json({ practiceByDay });
  } catch (error) {
    console.error('Error fetching activity data:', error);
    return NextResponse.json({ error: 'Failed to fetch activity data' }, { status: 500 });
  }
}

================
File: app/api/users/analytics/route.js
================
// app/api/users/analytics/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    // Get query parameters
    const searchParams = request.nextUrl.searchParams;
    const languageCode = searchParams.get('languageCode');
    const period = searchParams.get('period') || 'month'; // 'week', 'month', 'year'
    
    // Calculate date range based on period
    const endDate = new Date();
    const startDate = new Date();
    
    switch (period) {
      case 'week':
        startDate.setDate(startDate.getDate() - 7);
        break;
      case 'month':
        startDate.setMonth(startDate.getMonth() - 1);
        break;
      case 'year':
        startDate.setFullYear(startDate.getFullYear() - 1);
        break;
      default:
        startDate.setMonth(startDate.getMonth() - 1);
    }
    
    // Build query filters
    const filters = {
      userId: auth.userId,
      recordDate: {
        gte: startDate,
        lte: endDate
      }
    };
    
    if (languageCode) {
      filters.languageCode = languageCode;
    }
    
    // Get progress records
    const progressRecords = await prisma.progressRecord.findMany({
      where: filters,
      orderBy: {
        recordDate: 'desc'
      }
    });
    
    // Get challenge completions
    const challengeCompletions = await prisma.userChallenge.findMany({
      where: {
        userId: auth.userId,
        status: 'COMPLETED',
        endDate: {
          gte: startDate,
          lte: endDate
        }
      },
      include: {
        challenge: {
          select: {
            title: true,
            languageCode: true,
            stakeAmount: true,
            yieldPercentage: true
          }
        }
      }
    });
    
    // Get practice minutes
    const practiceMinutes = await prisma.dailyProgress.findMany({
      where: {
        userChallenge: {
          userId: auth.userId
        },
        date: {
          gte: startDate,
          lte: endDate
        }
      },
      select: {
        date: true,
        minutesPracticed: true,
        userChallenge: {
          select: {
            challenge: {
              select: {
                languageCode: true
              }
            }
          }
        }
      }
    });
    
    // Aggregate practice minutes by day and language
    const practiceByDay = {};
    
    practiceMinutes.forEach(record => {
      const lang = record.userChallenge.challenge.languageCode;
      const dateStr = record.date.toISOString().split('T')[0]; // YYYY-MM-DD
      
      if (!practiceByDay[dateStr]) {
        practiceByDay[dateStr] = {};
      }
      
      if (!practiceByDay[dateStr][lang]) {
        practiceByDay[dateStr][lang] = 0;
      }
      
      practiceByDay[dateStr][lang] += record.minutesPracticed;
    });
    
    // Get current streaks for each language
    const userLanguages = await prisma.userLanguage.findMany({
      where: {
        userId: auth.userId
      }
    });
    
    const streaksByLanguage = {};
    
    for (const lang of userLanguages) {
      // Get daily progress records for this language
      const langProgress = await prisma.dailyProgress.findMany({
        where: {
          userChallenge: {
            userId: auth.userId,
            challenge: {
              languageCode: lang.languageCode
            }
          },
          completed: true
        },
        orderBy: {
          date: 'desc'
        },
        select: {
          date: true
        }
      });
      
      // Calculate current streak
      let streak = 0;
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      
      // Check if there's a record for today
      const hasToday = langProgress.some(p => {
        const recordDate = new Date(p.date);
        recordDate.setHours(0, 0, 0, 0);
        return recordDate.getTime() === today.getTime();
      });
      
      if (hasToday) {
        streak = 1;
        
        // Check previous days
        let checkDate = new Date(today);
        checkDate.setDate(checkDate.getDate() - 1);
        
        while (true) {
          const hasDay = langProgress.some(p => {
            const recordDate = new Date(p.date);
            recordDate.setHours(0, 0, 0, 0);
            return recordDate.getTime() === checkDate.getTime();
          });
          
          if (hasDay) {
            streak++;
            checkDate.setDate(checkDate.getDate() - 1);
          } else {
            break;
          }
        }
      }
      
      streaksByLanguage[lang.languageCode] = streak;
    }
    
    // Compile analytics data
    const analytics = {
      progressRecords,
      challengeCompletions,
      practiceByDay,
      streaksByLanguage,
      summary: {
        totalPracticeMinutes: practiceMinutes.reduce((sum, record) => sum + record.minutesPracticed, 0),
        challengesCompleted: challengeCompletions.length,
        totalEarned: challengeCompletions.reduce((sum, challenge) => {
          const reward = challenge.challenge.stakeAmount * (1 + challenge.challenge.yieldPercentage / 100);
          return sum + reward;
        }, 0)
      }
    };
    
    return NextResponse.json(analytics);
  } catch (error) {
    console.error('Error fetching analytics:', error);
    return NextResponse.json({ error: 'Failed to fetch analytics' }, { status: 500 });
  }
}

================
File: app/api/users/profile/route.js
================
// app/api/users/profile/route.js
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { verifyAuth } from '@/lib/auth/verify';

const prisma = new PrismaClient();

export async function GET(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const user = await prisma.user.findUnique({
      where: { id: auth.userId },
      include: {
        learningLanguages: true
      }
    });
    
    if (!user) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 });
    }
    
    return NextResponse.json({
      id: user.id,
      walletAddress: user.walletAddress,
      username: user.username,
      email: user.email,
      avatarUrl: user.avatarUrl,
      nativeLanguage: user.nativeLanguage,
      learningLanguages: user.learningLanguages,
      createdAt: user.createdAt
    });
  } catch (error) {
    console.error('Error fetching user profile:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}


// Update user profile
export async function PUT(request) {
  const auth = await verifyAuth();
  
  if (!auth.success) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }
  
  try {
    const body = await request.json();
    
    // Validate request body
    if (!body.username || !body.email) {
      return NextResponse.json({ error: 'Username and email are required' }, { status: 400 });
    }
    
    // Create transaction to update user and learning languages
    const updatedUser = await prisma.$transaction(async (tx) => {
      // Update user basic info
      const user = await tx.user.update({
        where: { id: auth.userId },
        data: {
          username: body.username,
          email: body.email,
          nativeLanguage: body.nativeLanguage,
          avatarUrl: body.avatarUrl,
        },
        include: {
          learningLanguages: true
        }
      });
      
      // Update learning languages if provided
      if (body.learningLanguages && body.learningLanguages.length > 0) {
        // Get existing language codes for this user
        const existingLanguages = user.learningLanguages.map(lang => lang.languageCode);
        
        // Find languages to add (not in existing languages)
        const languagesToAdd = body.learningLanguages.filter(
          lang => !existingLanguages.includes(lang.languageCode)
        );
        
        // Add new languages
        if (languagesToAdd.length > 0) {
          await Promise.all(
            languagesToAdd.map(lang => 
              tx.userLanguage.create({
                data: {
                  userId: auth.userId,
                  languageCode: lang.languageCode,
                  proficiencyLevel: lang.proficiencyLevel,
                }
              })
            )
          );
        }
        
        // Update existing languages
        await Promise.all(
          body.learningLanguages
            .filter(lang => existingLanguages.includes(lang.languageCode))
            .map(lang => 
              tx.userLanguage.update({
                where: {
                  userId_languageCode: {
                    userId: auth.userId,
                    languageCode: lang.languageCode
                  }
                },
                data: {
                  proficiencyLevel: lang.proficiencyLevel
                }
              })
            )
        );
      }
      
      // Return updated user with fresh learning languages
      return tx.user.findUnique({
        where: { id: auth.userId },
        include: {
          learningLanguages: true
        }
      });
    });
    
    return NextResponse.json({
      id: updatedUser.id,
      walletAddress: updatedUser.walletAddress,
      username: updatedUser.username,
      email: updatedUser.email,
      avatarUrl: updatedUser.avatarUrl,
      nativeLanguage: updatedUser.nativeLanguage,
      learningLanguages: updatedUser.learningLanguages,
      createdAt: updatedUser.createdAt
    });
  } catch (error) {
    console.error('Error updating user profile:', error);
    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}

================
File: app/auth/signin/page.jsx
================
// app/auth/signin/page.jsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import Image from 'next/image';
import WalletConnectButton from '@/components/auth/WalletConnectButton';
import UserProfileForm from '@/components/auth/UserProfileForm';

export default function SignIn() {
  const router = useRouter();
  const [step, setStep] = useState('connect'); // 'connect' or 'profile'
  const [walletData, setWalletData] = useState(null);
  const [error, setError] = useState(null);
  
  const handleWalletSuccess = (data) => {
    setWalletData(data);
    
    // If user is already registered and profile is complete, redirect to dashboard
    if (!data.isNewUser) {
      router.push('/dashboard');
      return;
    }
    
    // Otherwise, proceed to profile setup
    setStep('profile');
  };
  
  const handleWalletError = (errorMessage) => {
    setError(errorMessage);
  };
  
  const handleProfileSuccess = () => {
    router.push('/dashboard');
  };
  
  const handleProfileError = (errorMessage) => {
    setError(errorMessage);
  };
  
  return (
    <div className="min-h-screen flex flex-col">
      <header className="bg-white py-4 shadow-sm">
        <div className="container mx-auto px-4">
          <div className="flex items-center">
            <div className="flex items-center space-x-2">
              <Image src="/logo.svg" alt="ShinobiSpeak Logo" width={40} height={40} />
              <span className="text-xl font-bold">ShinobiSpeak</span>
            </div>
          </div>
        </div>
      </header>
      
      <main className="flex-1 flex items-center justify-center p-4">
        <div className="bg-white p-8 rounded-lg shadow-lg max-w-md w-full">
          {error && (
            <div className="mb-4 p-3 bg-red-100 border border-red-400 text-red-700 rounded">
              {error}
              <button 
                className="float-right font-bold"
                onClick={() => setError(null)}
              >
                
              </button>
            </div>
          )}
          
          {step === 'connect' ? (
            <div className="text-center">
              <h1 className="text-2xl font-bold mb-6">Welcome to ShinobiSpeak</h1>
              <p className="mb-8 text-gray-600">
                Connect your wallet to sign in or create an account
              </p>
              
              <div className="mb-6">
                <WalletConnectButton
                  onSuccess={handleWalletSuccess}
                  onError={handleWalletError}
                />
              </div>
              
              <p className="text-sm text-gray-500">
                By connecting your wallet, you agree to our Terms of Service and Privacy Policy
              </p>
            </div>
          ) : (
            <div>
              <h1 className="text-2xl font-bold mb-6">Complete Your Profile</h1>
              <p className="mb-8 text-gray-600">
                Tell us more about yourself to get personalized language learning
              </p>
              
              <UserProfileForm
                walletAddress={walletData.walletAddress}
                onSuccess={handleProfileSuccess}
                onError={handleProfileError}
              />
            </div>
          )}
        </div>
      </main>
    </div>
  );
}

================
File: app/dashboard/challenges/[id]/page.jsx
================
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import DashboardLayout from '@/components/layout/DashboardLayout';
import YieldInformation from '@/components/challenge/YieldInformation';
import JoinChallengeFlow from '@/components/challenge/JoinChallengeFlow';
import { useStaking } from '@/lib/web3/hooks/useStaking';
import { useContract } from '@/lib/web3/hooks/useContract';
import LoadingState from '@/components/ui/LoadingState';
import ErrorMessage from '@/components/ui/ErrorMessage';

export default function ChallengePage({ params }) {
  const router = useRouter();
  const { id } = params;
  const [challenge, setChallenge] = useState(null);
  const [userParticipation, setUserParticipation] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showJoinFlow, setShowJoinFlow] = useState(false);
  
  const { isConnected, signer } = useContract();
  const { getStakeDetails } = useStaking();
  
  useEffect(() => {
    async function fetchChallengeData() {
      try {
        setIsLoading(true);
        setError(null);
        
        // Fetch challenge details
        const challengeRes = await fetch(`/api/challenges/${id}`);
        
        if (!challengeRes.ok) {
          throw new Error('Failed to fetch challenge details');
        }
        
        const challengeData = await challengeRes.json();
        setChallenge(challengeData);
        
        // Check if user is already participating
        const participationRes = await fetch(`/api/challenges/user?challengeId=${id}`);
        
        if (participationRes.ok) {
          const participationData = await participationRes.json();
          
          if (participationData.length > 0) {
            const participation = participationData[0];
            
            // Fetch today's progress if the user is participating
            if (participation.status === 'ACTIVE') {
              const todayRes = await fetch(`/api/challenges/daily-progress?userChallengeId=${participation.id}`);
              if (todayRes.ok) {
                const todayData = await todayRes.json();
                participation.todayProgress = todayData;
              }
            }
            
            // If user is connected to wallet, get on-chain stake details
            if (isConnected && signer) {
              try {
                const address = await signer.getAddress();
                const stakeDetails = await getStakeDetails(address, id);
                
                // Merge on-chain data with database data
                if (stakeDetails) {
                  participation.onChain = stakeDetails;
                }
              } catch (walletError) {
                console.error('Error fetching on-chain stake details:', walletError);
                // We can still continue with database info if on-chain lookup fails
              }
            }
            
            setUserParticipation(participation);
          }
        }
      } catch (error) {
        console.error('Error fetching challenge data:', error);
        setError(error.message || 'Failed to load challenge data');
      } finally {
        setIsLoading(false);
      }
    }
    
    if (id) {
      fetchChallengeData();
    }
  }, [id, isConnected, signer, getStakeDetails]);

  const renderProgressSection = () => {
    if (!userParticipation) return null;
    
    const { progressPercentage, currentStreak, longestStreak, status } = userParticipation;
    
    return (
      <div className="bg-white rounded-lg border border-slate-200 p-4 shadow-sm mb-6">
        <h3 className="text-lg font-medium text-slate-800 mb-4">Your Progress</h3>
        
        <div className="space-y-4">
          {/* Overall progress */}
          <div>
            <div className="flex justify-between text-sm text-slate-600 mb-1">
              <span>Overall Progress</span>
              <span>{progressPercentage}%</span>
            </div>
            <div className="w-full bg-slate-200 rounded-full h-2">
              <div 
                className="bg-gradient-to-r from-cyan-400 to-teal-500 h-2 rounded-full" 
                style={{ width: `${progressPercentage}%` }}
              ></div>
            </div>
          </div>
          
          {/* Today's progress */}
          {userParticipation.status === 'ACTIVE' && userParticipation.todayProgress && (
            <div>
              <div className="flex justify-between text-sm text-slate-600 mb-1">
                <span>Today's Practice</span>
                <span>{userParticipation.todayProgress.minutesPracticed}/{challenge.dailyRequirement} minutes</span>
              </div>
              <div className="w-full bg-slate-200 rounded-full h-2">
                <div 
                  className={`h-2 rounded-full ${
                    userParticipation.todayProgress.completed 
                      ? 'bg-green-500' 
                      : 'bg-gradient-to-r from-cyan-400 to-teal-500'
                  }`}
                  style={{ 
                    width: `${Math.min(100, (userParticipation.todayProgress.minutesPracticed / challenge.dailyRequirement) * 100)}%` 
                  }}
                ></div>
              </div>
              {userParticipation.todayProgress.completed && (
                <p className="text-sm text-green-600 mt-1">
                   Daily goal completed! Great job!
                </p>
              )}
            </div>
          )}
          
          {/* Streak info */}
          <div className="flex space-x-4">
            <div className="flex-1 bg-slate-50 rounded-lg p-3 border border-slate-200">
              <div className="text-sm text-slate-500">Current Streak</div>
              <div className="font-bold text-lg">{currentStreak} days</div>
            </div>
            
            <div className="flex-1 bg-slate-50 rounded-lg p-3 border border-slate-200">
              <div className="text-sm text-slate-500">Longest Streak</div>
              <div className="font-bold text-lg">{longestStreak} days</div>
            </div>
          </div>
          
          {/* Complete challenge button - only if challenge is active and progress is sufficient */}
          {status === 'ACTIVE' && progressPercentage >= 80 && (
            <button
              onClick={handleCompleteChallenge}
              className="w-full bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white px-6 py-3 rounded-lg font-medium shadow-md transition-all"
            >
              Complete Challenge & Claim Rewards
            </button>
          )}
          
          {/* If challenge is completed */}
          {status === 'COMPLETED' && (
            <div className="bg-green-50 text-green-700 border border-green-200 rounded-md p-3">
              <p className="font-medium">Challenge Completed!</p>
              <p className="text-sm mt-1">
                You successfully completed this challenge and earned your rewards.
              </p>
            </div>
          )}
          
          {/* If challenge is failed */}
          {status === 'FAILED' && (
            <div className="bg-red-50 text-red-700 border border-red-200 rounded-md p-3">
              <p className="font-medium">Challenge Failed</p>
              <p className="text-sm mt-1">
                Unfortunately, this challenge was not completed successfully.
              </p>
            </div>
          )}
        </div>
      </div>
    );
  };
  
  // Add this handler for the complete challenge button
  const handleCompleteChallenge = async () => {
    if (!userParticipation || userParticipation.status !== 'ACTIVE') {
      return;
    }
    
    try {
      setIsCompletingChallenge(true);
      
      const res = await fetch('/api/challenges/complete', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userChallengeId: userParticipation.id
        }),
      });
      
      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.error || 'Failed to complete challenge');
      }
      
      const data = await res.json();
      
      // Show success message
      setCompletionStatus({
        success: true,
        message: `Congratulations! You've completed the challenge and earned ${formatCurrency(data.reward)}`,
        transactionHash: data.transactionHash
      });
      
      // Refresh challenge data after a short delay
      setTimeout(() => {
        router.refresh();
      }, 3000);
    } catch (error) {
      console.error('Error completing challenge:', error);
      setCompletionStatus({
        success: false,
        message: error.message || 'Failed to complete challenge'
      });
    } finally {
      setIsCompletingChallenge(false);
    }
  };
  
  const handleJoinSuccess = (txHash) => {
    // Refresh the page data after successful join
    router.refresh();
    setShowJoinFlow(false);
  };
  
  // Get language flag emoji
  const getLanguageFlag = (code) => {
    const flags = {
      ja: "",
      ko: "",
      zh: "",
      en: "",
      es: "",
      fr: "",
      de: "",
      it: "",
      ru: ""
    };
    return flags[code] || "";
  };
  
  // Format currency
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  };
  
  if (isLoading) {
    return (
      <DashboardLayout>
        <div className="container mx-auto py-8">
          <LoadingState message="Loading challenge details..." height="96" />
        </div>
      </DashboardLayout>
    );
  }
  
  if (error) {
    return (
      <DashboardLayout>
        <div className="container mx-auto py-8">
          <ErrorMessage 
            title="Failed to load challenge" 
            message={error}
            retry={() => router.refresh()}
          />
        </div>
      </DashboardLayout>
    );
  }
  
  if (!challenge) {
    return (
      <DashboardLayout>
        <div className="container mx-auto py-8">
          <div className="text-center max-w-lg mx-auto">
            <h1 className="text-2xl font-bold text-gray-800 mb-4">Challenge Not Found</h1>
            <p className="text-gray-600 mb-6">The challenge you're looking for doesn't exist or has been removed.</p>
            <button
              onClick={() => router.push('/dashboard/challenges')}
              className="px-4 py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-lg hover:from-cyan-600 hover:to-teal-600"
            >
              View All Challenges
            </button>
          </div>
        </div>
      </DashboardLayout>
    );
  }
  
  // Show Join Flow if requested
  if (showJoinFlow) {
    return (
      <DashboardLayout>
        <div className="container mx-auto py-8">
          <JoinChallengeFlow 
            challenge={challenge}
            onSuccess={handleJoinSuccess}
            onCancel={() => setShowJoinFlow(false)}
          />
        </div>
      </DashboardLayout>
    );
  }
  
  return (
    <DashboardLayout>
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-4xl mx-auto">
          {/* Challenge header */}
          <div className="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden mb-8">
            <div className="bg-gradient-to-r from-cyan-500 to-teal-500 px-6 py-4 text-white">
              <div className="flex items-center">
                <span className="text-3xl mr-3">{getLanguageFlag(challenge.languageCode)}</span>
                <h1 className="text-2xl font-bold">{challenge.title}</h1>
              </div>
            </div>
            
            <div className="p-6">
              <p className="text-gray-600 mb-6">{challenge.description}</p>
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-100">
                  <h3 className="font-medium text-gray-700 mb-2">Duration</h3>
                  <p className="text-2xl font-bold text-gray-800">{challenge.durationDays} days</p>
                </div>
                
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-100">
                  <h3 className="font-medium text-gray-700 mb-2">Daily Requirement</h3>
                  <p className="text-2xl font-bold text-gray-800">{challenge.dailyRequirement} min/day</p>
                </div>
                
                <div className="bg-gray-50 p-4 rounded-lg border border-gray-100">
                  <h3 className="font-medium text-gray-700 mb-2">Stake Amount</h3>
                  <p className="text-2xl font-bold text-gray-800">{formatCurrency(challenge.stakeAmount)}</p>
                </div>
              </div>
              
              {/* Yield Information */}
              {userParticipation ? (
                <YieldInformation 
                  stakedAmount={challenge.stakeAmount}
                  yieldPercentage={challenge.yieldPercentage}
                  durationDays={challenge.durationDays}
                  challengeStartDate={userParticipation.startDate}
                  isHardcore={challenge.isHardcore}
                />
              ) : (
                <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
                  <h3 className="font-medium text-amber-800 mb-2">Reward Potential</h3>
                  <p className="text-gray-700">
                    Complete this challenge to earn back your {formatCurrency(challenge.stakeAmount)} stake
                    plus up to {challenge.yieldPercentage}% in additional rewards.
                  </p>
                </div>
              )}
              
              {challenge.isHardcore && !userParticipation && (
                <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-6">
                  <h3 className="font-medium text-red-800 mb-2">Hardcore Challenge</h3>
                  <p className="text-gray-700">
                    This is a hardcore challenge. If you fail to meet the daily requirements,
                    your stake will be forfeited to the community pool.
                  </p>
                </div>
              )}
              
              {userParticipation ? (
                <div className="bg-green-50 border border-green-200 rounded-lg p-4 mb-6">
                  <h3 className="font-medium text-green-800 mb-2">You're Participating!</h3>
                  <p className="text-gray-700 mb-4">
                    You joined this challenge on {new Date(userParticipation.startDate).toLocaleDateString()}.
                    Your current progress is {userParticipation.progressPercentage}%.
                  </p>
                  
                  <button
                    onClick={() => router.push(`/dashboard/learn?challengeId=${challenge.id}`)}
                    className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-6 py-3 rounded-lg font-medium shadow-md transition-all w-full"
                  >
                    Continue Practice
                  </button>
                </div>
              ) : (
                <button
                  onClick={() => setShowJoinFlow(true)}
                  className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-6 py-3 rounded-lg font-medium shadow-md transition-all w-full disabled:opacity-50"
                >
                  {`Stake ${formatCurrency(challenge.stakeAmount)} & Join Challenge`}
                </button>
              )}
            </div>
          </div>
          
          {/* Challenge details */}
          <div className="bg-white rounded-xl shadow-sm border border-gray-100 overflow-hidden">
            <div className="px-6 py-4 border-b border-gray-100">
              <h2 className="text-xl font-bold text-gray-800">How This Challenge Works</h2>
            </div>
            
            <div className="p-6">
              <div className="space-y-6">
                <div className="flex">
                  <div className="flex-shrink-0 w-10 h-10 rounded-full bg-cyan-100 flex items-center justify-center text-cyan-600 mr-4">
                    1
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-800 mb-1">Stake your USDC</h3>
                    <p className="text-gray-600">
                      Commit to your learning by staking {formatCurrency(challenge.stakeAmount)}.
                      Your funds are securely locked in our smart contract.
                    </p>
                  </div>
                </div>
                
                <div className="flex">
                  <div className="flex-shrink-0 w-10 h-10 rounded-full bg-cyan-100 flex items-center justify-center text-cyan-600 mr-4">
                    2
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-800 mb-1">Practice daily</h3>
                    <p className="text-gray-600">
                      Complete at least {challenge.dailyRequirement} minutes of language practice
                      each day with our AI tutors.
                    </p>
                  </div>
                </div>
                
                <div className="flex">
                  <div className="flex-shrink-0 w-10 h-10 rounded-full bg-cyan-100 flex items-center justify-center text-cyan-600 mr-4">
                    3
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-800 mb-1">Track your progress</h3>
                    <p className="text-gray-600">
                      Monitor your learning streak and vocabulary growth on your dashboard.
                      Our AI will evaluate your language improvements.
                    </p>
                  </div>
                </div>
                
                <div className="flex">
                  <div className="flex-shrink-0 w-10 h-10 rounded-full bg-cyan-100 flex items-center justify-center text-cyan-600 mr-4">
                    4
                  </div>
                  <div>
                    <h3 className="font-medium text-gray-800 mb-1">Earn rewards</h3>
                    <p className="text-gray-600">
                      Complete the {challenge.durationDays}-day challenge to earn back your
                      stake plus additional rewards from generated yield.
                    </p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </DashboardLayout>
  );
}

================
File: app/dashboard/challenges/create/page.jsx
================
'use client';

// app/dashboard/challenges/create/page.jsx
import dynamic from 'next/dynamic';
import { Suspense } from 'react';
import DashboardLayout from '@/components/layout/DashboardLayout';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';

// Dynamically import the challenge creation form to avoid hydration issues with wallet connection
const CreateChallengeForm = dynamic(
  () => import('@/components/challenge/CreateChallengeForm'),
  { 
    ssr: false,
    loading: () => (
      <div className="flex justify-center items-center py-12">
        <LoadingSpinner size="large" />
      </div>
    )
  }
);

export default function Page() {
  return (
    <Suspense fallback={
      <DashboardLayout>
        <div className="py-8">
          <div className="max-w-3xl mx-auto text-center">
            <LoadingSpinner size="large" />
            <p className="mt-4 text-gray-500">Loading challenge creation form...</p>
          </div>
        </div>
      </DashboardLayout>
    }>
      <CreateChallengeForm />
    </Suspense>
  );
}

================
File: app/dashboard/challenges/page.jsx
================
// app/dashboard/challenges/page.jsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import Link from 'next/link';
import DashboardLayout from '@/components/layout/DashboardLayout';
import ChallengeCard from '@/components/dashboard/ChallengeCard';
import LoadingState from '@/components/ui/LoadingState';
import EmptyState from '@/components/ui/EmptyState';

export default function ChallengesPage() {
  const router = useRouter();
  const [challenges, setChallenges] = useState([]);
  const [activeChallenges, setActiveChallenges] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    async function fetchChallenges() {
      try {
        setIsLoading(true);
        
        // Fetch active challenges for this user
        const activeRes = await fetch('/api/challenges/user?status=ACTIVE');
        
        if (!activeRes.ok) {
          throw new Error('Failed to fetch active challenges');
        }
        
        const activeData = await activeRes.json();
        setActiveChallenges(activeData);
        
        // Fetch available challenges
        const availableRes = await fetch('/api/challenges');
        
        if (!availableRes.ok) {
          throw new Error('Failed to fetch available challenges');
        }
        
        const availableData = await availableRes.json();
        setChallenges(availableData);
      } catch (error) {
        console.error('Error fetching challenges:', error);
        setError(error.message);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchChallenges();
  }, []);
  
  if (isLoading) {
    return (
      <DashboardLayout>
        <div className="container mx-auto py-8 px-4">
          <LoadingState message="Loading challenges..." height="64" />
        </div>
      </DashboardLayout>
    );
  }
  
  return (
    <DashboardLayout>
      <div className="container mx-auto py-8 px-4">
        <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-8">
          <div>
            <h1 className="text-2xl font-bold text-gray-900 mb-2">Challenges</h1>
            <p className="text-gray-600">Accelerate your language learning with challenges</p>
          </div>
          <Link 
            href="/dashboard/challenges/create"
            className="mt-4 md:mt-0 bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-6 py-3 rounded-lg font-medium shadow-md transition-all"
          >
            Create New Challenge
          </Link>
        </div>
        
        {error && (
          <div className="mb-8 bg-red-50 border border-red-200 text-red-700 px-4 py-3 rounded-lg">
            <p className="font-medium">Error loading challenges</p>
            <p className="text-sm">{error}</p>
          </div>
        )}
        
        {/* Active Challenges Section */}
        <div className="mb-10">
          <h2 className="text-xl font-bold text-gray-800 mb-4">Your Active Challenges</h2>
          
          {activeChallenges.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {activeChallenges.map(challenge => (
                <ChallengeCard 
                  key={challenge.id}
                  challenge={challenge.challenge}
                  userChallenge={challenge}
                  isActive={true}
                  onClick={() => router.push(`/dashboard/challenges/${challenge.challengeId}`)}
                />
              ))}
            </div>
          ) : (
            <EmptyState 
              title="No active challenges"
              message="Join an existing challenge or create your own to get started!"
              action={{
                text: "Create Challenge",
                onClick: () => router.push('/dashboard/challenges/create')
              }}
            />
          )}
        </div>
        
        {/* Available Challenges Section */}
        <div>
          <h2 className="text-xl font-bold text-gray-800 mb-4">Available Challenges</h2>
          
          {challenges.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {challenges
                .filter(c => !activeChallenges.some(ac => ac.challengeId === c.id))
                .map(challenge => (
                  <ChallengeCard 
                    key={challenge.id}
                    challenge={challenge}
                    isActive={false}
                    onClick={() => router.push(`/dashboard/challenges/${challenge.id}`)}
                  />
              ))}
            </div>
          ) : (
            <EmptyState 
              title="No challenges available"
              message="Be the first to create a challenge for the community!"
              action={{
                text: "Create First Challenge",
                onClick: () => router.push('/dashboard/challenges/create')
              }}
            />
          )}
        </div>
      </div>
    </DashboardLayout>
  );
}

================
File: app/dashboard/learn/page.jsx
================
// app/dashboard/learn/page.jsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter, useSearchParams } from 'next/navigation';
import DashboardLayout from '@/components/layout/DashboardLayout';
import ConversationInterface from '@/components/learn/ConversationInterface';

export default function LearnPage() {
  const router = useRouter();
  const searchParams = useSearchParams();
  const [userChallenge, setUserChallenge] = useState(null);
  const [challengeId, setChallengeId] = useState(null);
  const [languageCode, setLanguageCode] = useState('en');
  const [isLoading, setIsLoading] = useState(true);
  const [showConversation, setShowConversation] = useState(false);
  
  useEffect(() => {
    async function fetchUserChallengeData() {
      try {
        setIsLoading(true);
        const id = searchParams.get('challengeId');
        
        if (id) {
          setChallengeId(id);
          
          // Fetch challenge participation details
          const res = await fetch(`/api/challenges/user?challengeId=${id}`);
          
          if (res.ok) {
            const data = await res.json();
            if (data.length > 0) {
              setUserChallenge(data[0]);
              
              // Fetch language code from challenge
              const challengeRes = await fetch(`/api/challenges/${id}`);
              if (challengeRes.ok) {
                const challengeData = await challengeRes.json();
                setLanguageCode(challengeData.languageCode);
              }
            }
          }
        } else {
          // No challenge ID provided, use user's preferred language
          const userRes = await fetch('/api/users/profile');
          if (userRes.ok) {
            const userData = await userRes.json();
            if (userData.learningLanguages && userData.learningLanguages.length > 0) {
              setLanguageCode(userData.learningLanguages[0].languageCode);
            }
          }
        }
      } catch (error) {
        console.error('Error fetching challenge data:', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchUserChallengeData();
  }, [searchParams]);
  
  const handleStartConversation = () => {
    setShowConversation(true);
  };
  
  if (showConversation) {
    return (
      <ConversationInterface 
        languageCode={languageCode} 
        userChallengeId={userChallenge?.id}
      />
    );
  }
  
  return (
    <DashboardLayout>
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-3xl mx-auto">
          <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden mb-8">
            <div className="px-6 py-4 border-b border-slate-100">
              <h1 className="text-2xl font-bold text-slate-800 flex items-center">
                <span className="text-3xl mr-3">
                  {languageCode === 'ja' ? '' : 
                   languageCode === 'ko' ? '' : 
                   languageCode === 'zh' ? '' : 
                   languageCode === 'en' ? '' : 
                   languageCode === 'es' ? '' : 
                   languageCode === 'fr' ? '' : ''}
                </span>
                {languageCode === 'ja' ? 'Japanese' : 
                 languageCode === 'ko' ? 'Korean' : 
                 languageCode === 'zh' ? 'Chinese' : 
                 languageCode === 'en' ? 'English' : 
                 languageCode === 'es' ? 'Spanish' : 
                 languageCode === 'fr' ? 'French' : 'Language'} Practice
              </h1>
            </div>
            
            <div className="p-6">
              {userChallenge ? (
                <div className="mb-6">
                  <h2 className="font-medium text-slate-800 mb-2">Challenge Progress</h2>
                  <div className="bg-slate-50 p-4 rounded-lg border border-slate-100">
                    <div className="flex justify-between mb-2">
                      <span className="text-slate-600">Daily Goal:</span>
                      <span className="font-medium text-slate-800">
                        0/{userChallenge.challenge?.dailyRequirement} minutes
                      </span>
                    </div>
                    <div className="w-full bg-slate-200 rounded-full h-2 mb-4">
                      <div className="bg-gradient-to-r from-cyan-500 to-teal-500 h-2 rounded-full w-0"></div>
                    </div>
                    <div className="text-sm text-slate-500">
                      Complete {userChallenge.challenge?.dailyRequirement} minutes of practice today to maintain your streak.
                    </div>
                  </div>
                </div>
              ) : (
                <div className="mb-6">
                  <div className="bg-amber-50 p-4 rounded-lg border border-amber-100">
                    <h2 className="font-medium text-amber-800 mb-2">Free Practice Session</h2>
                    <p className="text-slate-600">
                      You're in free practice mode. Consider joining a challenge to track your progress 
                      and earn rewards for consistent practice.
                    </p>
                  </div>
                </div>
              )}
              
              <div className="mb-6">
                <h2 className="font-medium text-slate-800 mb-2">Practice Options</h2>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div className="bg-slate-50 p-4 rounded-lg border border-slate-100 hover:border-cyan-300 cursor-pointer" onClick={handleStartConversation}>
                    <h3 className="font-medium text-slate-700 flex items-center mb-2">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M18 10c0 3.866-3.582 7-8 7a8.841 8.841 0 01-4.083-.98L2 17l1.338-3.123C2.493 12.767 2 11.434 2 10c0-3.866 3.582-7 8-7s8 3.134 8 7zM7 9H5v2h2V9zm8 0h-2v2h2V9zM9 9h2v2H9V9z" clipRule="evenodd" />
                      </svg>
                      Free Conversation
                    </h3>
                    <p className="text-sm text-slate-600">
                      Practice natural conversation on any topic with our AI language tutor.
                    </p>
                  </div>
                  
                  <div className="bg-slate-50 p-4 rounded-lg border border-slate-100 hover:border-cyan-300 cursor-pointer">
                    <h3 className="font-medium text-slate-700 flex items-center mb-2">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" />
                      </svg>
                      Vocabulary Practice
                    </h3>
                    <p className="text-sm text-slate-600">
                      Focus on expanding your vocabulary with targeted exercises.
                    </p>
                  </div>
                  
                  <div className="bg-slate-50 p-4 rounded-lg border border-slate-100 hover:border-cyan-300 cursor-pointer">
                    <h3 className="font-medium text-slate-700 flex items-center mb-2">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h6a1 1 0 110 2H4a1 1 0 01-1-1z" clipRule="evenodd" />
                      </svg>
                      Grammar Exercises
                    </h3>
                    <p className="text-sm text-slate-600">
                      Practice specific grammar points with structured exercises.
                    </p>
                  </div>
                  
                  <div className="bg-slate-50 p-4 rounded-lg border border-slate-100 hover:border-cyan-300 cursor-pointer">
                    <h3 className="font-medium text-slate-700 flex items-center mb-2">
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clipRule="evenodd" />
                      </svg>
                      Listening Comprehension
                    </h3>
                    <p className="text-sm text-slate-600">
                      Improve your listening skills with audio exercises and questions.
                    </p>
                  </div>
                </div>
              </div>
              
              <div className="bg-teal-50 p-4 rounded-lg border border-teal-100">
                <h2 className="font-medium text-teal-800 mb-2">AI Tutor Tips</h2>
                <ul className="text-sm text-slate-600 space-y-2">
                  <li className="flex items-start">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-teal-500 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    Try to speak in complete sentences to get better feedback.
                  </li>
                  <li className="flex items-start">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-teal-500 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    The AI will provide corrections in [brackets] when you make mistakes.
                  </li>
                  <li className="flex items-start">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-teal-500 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    Don't hesitate to ask the AI to explain grammar or vocabulary.
                  </li>
                  <li className="flex items-start">
                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-teal-500 flex-shrink-0" viewBox="0 0 20 20" fill="currentColor">
                      <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                    </svg>
                    Practice for at least 15-20 minutes for the best learning experience.
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    </DashboardLayout>
  );
}

================
File: app/dashboard/statistics/page.jsx
================
// app/dashboard/statistics/page.jsx
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import DashboardLayout from '@/components/layout/DashboardLayout';
import { format, subDays, eachDayOfInterval } from 'date-fns';

export default function StatisticsPage() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);
  const [analyticsData, setAnalyticsData] = useState(null);
  const [selectedLanguage, setSelectedLanguage] = useState('all');
  const [timeRange, setTimeRange] = useState('month');
  
  useEffect(() => {
    async function fetchAnalytics() {
      try {
        setIsLoading(true);
        
        // Construct query params
        const params = new URLSearchParams();
        if (selectedLanguage !== 'all') {
          params.append('languageCode', selectedLanguage);
        }
        params.append('period', timeRange);
        
        const response = await fetch(`/api/users/analytics?${params.toString()}`);
        
        if (!response.ok) {
          if (response.status === 401) {
            router.push('/auth/signin');
            return;
          }
          throw new Error('Failed to fetch analytics');
        }
        
        const data = await response.json();
        setAnalyticsData(data);
      } catch (error) {
        console.error('Error fetching analytics:', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchAnalytics();
  }, [selectedLanguage, timeRange, router]);
  
  // Function to generate chart data
  const generateChartData = () => {
    if (!analyticsData?.practiceByDay) return [];
    
    // Calculate date range
    const endDate = new Date();
    let startDate;
    
    switch (timeRange) {
      case 'week':
        startDate = subDays(endDate, 7);
        break;
      case 'month':
        startDate = subDays(endDate, 30);
        break;
      case 'year':
        startDate = subDays(endDate, 365);
        break;
      default:
        startDate = subDays(endDate, 30);
    }
    
    // Generate all dates in range
    const dateRange = eachDayOfInterval({ start: startDate, end: endDate });
    
    // Format dates and map to practice minutes
    return dateRange.map(date => {
      const dateString = format(date, 'yyyy-MM-dd');
      const dayData = analyticsData.practiceByDay[dateString] || {};
      
      // If specific language selected, return only that language data
      if (selectedLanguage !== 'all') {
        return {
          date: format(date, 'MMM dd'),
          minutes: dayData[selectedLanguage] || 0
        };
      }
      
      // Otherwise, sum all languages
      const totalMinutes = Object.values(dayData).reduce((sum, min) => sum + min, 0);
      
      return {
        date: format(date, 'MMM dd'),
        minutes: totalMinutes
      };
    });
  };
  
  if (isLoading) {
    return (
      <DashboardLayout>
        <div className="container mx-auto px-4 py-8">
          <div className="animate-pulse space-y-4 max-w-4xl mx-auto">
            <div className="h-8 bg-slate-200 rounded w-1/4"></div>
            <div className="h-64 bg-slate-200 rounded"></div>
            <div className="h-8 bg-slate-200 rounded w-1/3"></div>
            <div className="h-40 bg-slate-200 rounded"></div>
          </div>
        </div>
      </DashboardLayout>
    );
  }
  
  const chartData = generateChartData();
  
   // Get language name from language code
   const getLanguageName = (code) => {
    const languages = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ru': 'Russian',
      'pt': 'Portuguese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    
    return languages[code] || code;
  };

  return (
    <DashboardLayout>
      <div className="container mx-auto px-4 py-8">
        <div className="max-w-6xl mx-auto">
          <div className="flex justify-between items-center mb-6">
            <h1 className="text-2xl font-bold text-slate-800">Learning Statistics</h1>
            
            <div className="flex space-x-4">
              <select
                value={selectedLanguage}
                onChange={(e) => setSelectedLanguage(e.target.value)}
                className="px-4 py-2 border border-slate-300 rounded-lg bg-white"
              >
                <option value="all">All Languages</option>
                {analyticsData?.streaksByLanguage && Object.keys(analyticsData.streaksByLanguage).map(lang => (
                  <option key={lang} value={lang}>
                    {getLanguageName(lang)}
                  </option>
                ))}
              </select>
              
              <select
                value={timeRange}
                onChange={(e) => setTimeRange(e.target.value)}
                className="px-4 py-2 border border-slate-300 rounded-lg bg-white"
              >
                <option value="week">Last 7 days</option>
                <option value="month">Last 30 days</option>
                <option value="year">Last 365 days</option>
              </select>
            </div>
          </div>
          
          {/* Summary Stats */}
          {/* <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <StatCard 
              title="Total Practice Time" 
              value={`${analyticsData?.summary?.totalPracticeMinutes || 0} minutes`} 
              icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-cyan-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>}
              color="cyan"
            />
            
            <StatCard 
              title="Challenges Completed" 
              value={analyticsData?.challengeCompletions?.length || 0} 
              icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>}
              color="green"
            />
            
            <StatCard 
              title="Total Rewards Earned" 
              value={`$${analyticsData?.summary?.totalEarned?.toFixed(2) || '0.00'}`} 
              icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-amber-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
                <path strokeLinecap="round" strokeLinejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
              </svg>}
              color="amber"
            />
          </div> */}
          
          {/* Practice Chart */}
          <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden mb-8">
            <div className="px-6 py-4 border-b border-slate-100">
              <h2 className="text-xl font-bold text-slate-800">Practice Minutes</h2>
            </div>
            
            <div className="p-6">
              <div className="h-64">
                {/* <PracticeChart data={chartData} /> */}
              </div>
            </div>
          </div>
          
          {/* Current Streaks */}
          <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden mb-8">
            <div className="px-6 py-4 border-b border-slate-100">
              <h2 className="text-xl font-bold text-slate-800">Current Streaks</h2>
            </div>
            
            <div className="p-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                {analyticsData?.streaksByLanguage && Object.entries(analyticsData.streaksByLanguage).map(([lang, streak]) => (
                  <div key={lang} className="bg-slate-50 p-4 rounded-lg border border-slate-100">
                    <div className="flex items-center mb-2">
                      <span className="text-2xl mr-2">
                        {lang === 'ja' ? '' : 
                         lang === 'ko' ? '' : 
                         lang === 'zh' ? '' : 
                         lang === 'en' ? '' : 
                         lang === 'es' ? '' : 
                         lang === 'fr' ? '' : ''}
                      </span>
                      <h3 className="font-medium text-slate-700">{getLanguageName(lang)}</h3>
                    </div>
                    <div className="flex items-end">
                      <span className="text-3xl font-bold text-cyan-600">{streak}</span>
                      <span className="ml-2 text-slate-500">days</span>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </div>
          
          {/* Recent Challenges */}
          {analyticsData?.challengeCompletions?.length > 0 && (
            <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
              <div className="px-6 py-4 border-b border-slate-100">
                <h2 className="text-xl font-bold text-slate-800">Completed Challenges</h2>
              </div>
              
              <div className="p-6">
                <div className="overflow-x-auto">
                  <table className="w-full border-collapse">
                    <thead>
                      <tr className="bg-slate-50">
                        <th className="px-4 py-2 text-left text-slate-700 border-b border-slate-200">Challenge</th>
                        <th className="px-4 py-2 text-left text-slate-700 border-b border-slate-200">Language</th>
                        <th className="px-4 py-2 text-right text-slate-700 border-b border-slate-200">Stake</th>
                        <th className="px-4 py-2 text-right text-slate-700 border-b border-slate-200">Reward</th>
                        <th className="px-4 py-2 text-right text-slate-700 border-b border-slate-200">Completion Date</th>
                      </tr>
                    </thead>
                    <tbody>
                      {analyticsData.challengeCompletions.map((completion) => {
                        const reward = completion.challenge.stakeAmount * (1 + completion.challenge.yieldPercentage / 100);
                        
                        return (
                          <tr key={completion ?.id} className="border-b border-slate-200">
                            <td className="px-4 py-2 text-slate-700">{completion.challenge.title}</td>
                            <td className="px-4 py-2 text-slate-700">{getLanguageName(completion.challenge.languageCode)}</td>
                            <td className="px-4 py-2 text-right text-slate-700">${completion.challenge.stakeAmount.toFixed(2)}</td>
                            <td className="px-4 py-2 text-right text-slate-700">${reward.toFixed(2)}</td>
                            <td className="px-4 py-2 text-right text-slate-700">{completion.completionDate}</td>
                          </tr>
                        );
                      })}
                    </tbody>
                  </table>
                </div>
              </div>
            </div>
          )}
        </div>    
        </div>                                                          
      </DashboardLayout>
    );
  };

================
File: app/dashboard/page.jsx
================
// app/dashboard/page.jsx
'use client';

import { useEffect, useState } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useRouter } from 'next/navigation';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner'; 

export default function Dashboard() {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(true);
  const [profile, setProfile] = useState(null);
  const [activeChallenges, setActiveChallenges] = useState([]);
  const [todayChallenge, setTodayChallenge] = useState(null);
  const [activityData, setActivityData] = useState([]);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    // Fetch user profile and challenges
    async function fetchUserData() {
      try {
        setIsLoading(true);
        setError(null);
        
        // Fetch user profile
        const profileRes = await fetch('/api/users/profile');
        if (!profileRes.ok) {
          if (profileRes.status === 401) {
            // Redirect to login if unauthorized
            router.push('/auth/signin');
            return;
          }
          throw new Error('Failed to fetch user profile');
        }
        const profileData = await profileRes.json();
        
        // Fetch user stats
        const statsRes = await fetch('/api/users/analytics');
        let statsData = {};
        if (statsRes.ok) {
          const analyticsData = await statsRes.json();
          statsData = {
            totalMinutesPracticed: analyticsData.summary?.totalPracticeMinutes || 0,
            vocabularySize: analyticsData.progressRecords?.[0]?.vocabularySize || 0,
            currentStreak: Object.values(analyticsData.streaksByLanguage || {})[0] || 0,
            longestStreak: analyticsData.progressRecords?.[0]?.longestStreak || 0
          };
        }
        
        // Combine profile with stats
        const fullProfile = {
          ...profileData,
          stats: statsData
        };
        setProfile(fullProfile);
        
        // Fetch active challenges
        const challengesRes = await fetch('/api/challenges/user?status=ACTIVE');
        if (challengesRes.ok) {
          const challengesData = await challengesRes.json();
          
          // Transform challenge data to match the expected format
          const formattedChallenges = challengesData.map(challenge => {
            const startDate = new Date(challenge.startDate);
            const endDate = new Date(challenge.endDate);
            const today = new Date();
            const daysLeft = Math.ceil((endDate - today) / (1000 * 60 * 60 * 24));
            
            return {
              id: challenge.challengeId,
              title: challenge.challenge.title,
              languageCode: challenge.challenge.languageCode,
              proficiencyLevel: challenge.challenge.proficiencyLevel,
              durationDays: challenge.challenge.durationDays,
              daysLeft: daysLeft > 0 ? daysLeft : 0,
              dailyRequirement: challenge.challenge.dailyRequirement,
              stakeAmount: challenge.stakedAmount,
              progress: challenge.progressPercentage
            };
          });
          
          setActiveChallenges(formattedChallenges);
          
          // Set today's challenge if there are active challenges
          if (formattedChallenges.length > 0) {
            // Prioritize the challenge with the lowest days left
            const sortedChallenges = [...formattedChallenges].sort((a, b) => a.daysLeft - b.daysLeft);
            const nextChallenge = sortedChallenges[0];
            
            // Fetch today's exercise for this challenge
            try {
              const exerciseRes = await fetch(`/api/challenges/${nextChallenge.id}/daily-exercise`);
              if (exerciseRes.ok) {
                const exerciseData = await exerciseRes.json();
                setTodayChallenge({
                  id: nextChallenge.id,
                  title: nextChallenge.title,
                  description: exerciseData.description || "Continue your daily practice to maintain your streak!",
                  exercise: exerciseData.exercise || `Practice ${nextChallenge.dailyRequirement} minutes of ${nextChallenge.languageCode === 'ja' ? 'Japanese' : nextChallenge.languageCode === 'ko' ? 'Korean' : 'language'} today.`,
                  languageCode: nextChallenge.languageCode
                });
              } else {
                // Fallback if no specific exercise
                setTodayChallenge({
                  id: nextChallenge.id,
                  title: nextChallenge.title,
                  description: "Continue your daily practice to maintain your streak!",
                  exercise: `Practice ${nextChallenge.dailyRequirement} minutes of ${nextChallenge.languageCode === 'ja' ? 'Japanese' : nextChallenge.languageCode === 'ko' ? 'Korean' : 'language'} today.`,
                  languageCode: nextChallenge.languageCode
                });
              }
            } catch (exerciseError) {
              console.error('Error fetching daily exercise:', exerciseError);
              // Fallback
              setTodayChallenge({
                id: nextChallenge.id,
                title: nextChallenge.title,
                description: "Continue your daily practice to maintain your streak!",
                exercise: `Practice ${nextChallenge.dailyRequirement} minutes of ${nextChallenge.languageCode === 'ja' ? 'Japanese' : nextChallenge.languageCode === 'ko' ? 'Korean' : 'language'} today.`,
                languageCode: nextChallenge.languageCode
              });
            }
          }
        }
        
        // Fetch weekly activity data
        const activityRes = await fetch('/api/users/activity?period=week');
        if (activityRes.ok) {
          const activityData = await activityRes.json();
          
          // Transform activity data to match the expected format
          const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
          const today = new Date();
          const dayOfWeek = today.getDay(); // 0 = Sunday, 6 = Saturday
          
          const weeklyActivity = days.map((day, index) => {
            const isToday = index === dayOfWeek;
            const dateStr = getDateString(new Date(today.getTime() - ((dayOfWeek - index + 7) % 7) * 24 * 60 * 60 * 1000));
            const minutesForDay = activityData.practiceByDay?.[dateStr] ? 
              Object.values(activityData.practiceByDay[dateStr]).reduce((sum, val) => sum + val, 0) : 0;
            
            return {
              day,
              minutes: minutesForDay,
              isToday
            };
          });
          
          setActivityData(weeklyActivity);
        } else {
          // Fallback to dummy data if API fails
          const dummyActivity = generateDummyActivityData();
          setActivityData(dummyActivity);
        }
        
        setIsLoading(false);
      } catch (error) {
        console.error('Error fetching dashboard data:', error);
        setError(error.message);
        setIsLoading(false);
      }
    }
    
    fetchUserData();
  }, [router]);
  
  // Helper function to generate date string in YYYY-MM-DD format
  const getDateString = (date) => {
    return date.toISOString().split('T')[0];
  };
  
  // Generate dummy activity data if API fails
  const generateDummyActivityData = () => {
    const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
    const today = new Date();
    const dayOfWeek = today.getDay();
    
    return days.map((day, index) => ({
      day,
      minutes: Math.floor(Math.random() * 45) + 5, // Random between 5-50
      isToday: index === dayOfWeek
    }));
  };
  
  // Handle starting today's challenge
  const handleStartChallenge = () => {
    if (todayChallenge) {
      router.push(`/dashboard/learn?challengeId=${todayChallenge.id}`);
    }
  };
  
  // Handle creating a new challenge
  const handleNewChallenge = () => {
    router.push('/dashboard/challenges/create');
  };
  
  if (isLoading) {
    return <LoadingScreen />;
  }
  
  if (error) {
    return (
      <div className="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-4">
        <div className="bg-white p-8 rounded-lg shadow-md max-w-md w-full">
          <h1 className="text-2xl font-bold text-red-600 mb-4">Error Loading Dashboard</h1>
          <p className="text-slate-600 mb-6">{error}</p>
          <button 
            onClick={() => window.location.reload()}
            className="w-full bg-gradient-to-r from-cyan-500 to-teal-500 text-white py-3 px-6 rounded-lg font-medium shadow-md"
          >
            Try Again
          </button>
        </div>
      </div>
    );
  }
  
  return (
    <div className="min-h-screen bg-slate-50 text-slate-800">
      {/* Robot mascot floating in corner */}
      <div className="fixed bottom-20 right-6 hidden lg:block z-10 animate-float">
        <RobotAvatar size="large" />
      </div>
      
      {/* Dashboard Header */}
      <header className="bg-white shadow-sm py-4 px-6">
        <div className="max-w-7xl mx-auto flex justify-between items-center">
          <div className="flex items-center">
            <div className="mr-3">
              <RobotAvatar size="small" />
            </div>
            <div>
              <h1 className="text-2xl font-bold text-slate-800">
                , <span className="text-cyan-600">{profile?.username || 'Learner'}</span>!
              </h1>
              <p className="text-slate-500">Your learning adventure continues...</p>
            </div>
          </div>
          
          <div className="flex space-x-3">
            <button 
              className="bg-white border border-slate-200 hover:bg-slate-50 text-slate-700 px-4 py-2 rounded-lg flex items-center shadow-sm transition-colors"
              onClick={() => router.push('/dashboard')}
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1 text-slate-400" viewBox="0 0 20 20" fill="currentColor">
                <path d="M5 3a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2V5a2 2 0 00-2-2H5zM5 11a2 2 0 00-2 2v2a2 2 0 002 2h2a2 2 0 002-2v-2a2 2 0 00-2-2H5zM11 5a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V5zM11 13a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" />
              </svg>
              <span>Dashboard</span>
            </button>
            
            <button 
              className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-4 py-2 rounded-lg flex items-center shadow-md transition-all transform hover:translate-y-[-2px]"
              onClick={handleNewChallenge}
            >
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-11a1 1 0 10-2 0v2H7a1 1 0 100 2h2v2a1 1 0 102 0v-2h2a1 1 0 100-2h-2V7z" clipRule="evenodd" />
              </svg>
              <span>New Challenge</span>
            </button>
          </div>
        </div>
      </header>
      
      <main className="px-6 py-6">
        <div className="max-w-7xl mx-auto">
          {/* Main dashboard grid */}
          <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
            {/* Left column */}
            <div className="lg:col-span-2 space-y-6">
              {/* Today's Challenge Card */}
              {todayChallenge ? (
                <TodaysChallenge challenge={todayChallenge} onStart={handleStartChallenge} />
              ) : (
                <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
                  <div className="border-b border-slate-100 bg-gradient-to-r from-cyan-50 to-teal-50 px-6 py-4">
                    <h2 className="text-xl font-bold text-slate-800">No Active Challenges</h2>
                  </div>
                  <div className="p-6">
                    <p className="text-slate-600 mb-6">
                      You don't have any active challenges yet. Start a new challenge to begin your language learning journey!
                    </p>
                    <button 
                      onClick={handleNewChallenge}
                      className="w-full bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white py-3 px-6 rounded-lg font-medium shadow-md transition-all transform hover:translate-y-[-2px] flex items-center justify-center"
                    >
                      Create Your First Challenge
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
                      </svg>
                    </button>
                  </div>
                </div>
              )}
              
              {/* My Learning Stats */}
              <LearningStats stats={profile?.stats || {
                totalMinutesPracticed: 0,
                vocabularySize: 0,
                currentStreak: 0,
                longestStreak: 0
              }} />
              
              {/* Progress Charts */}
              <ActivityChart data={activityData} />
            </div>
            
            {/* Right column */}
            <div className="space-y-6">
              {/* User Profile Card */}
              <UserProfileCard profile={profile} />
              
              {/* Active Challenges */}
              <ActiveChallenges 
                challenges={activeChallenges} 
                onViewChallenge={(id) => router.push(`/dashboard/challenges/${id}`)}
                onViewAll={() => router.push('/dashboard/challenges')}
              />
            </div>
          </div>
          
          {/* Learning Path Section */}
          <div className="mt-8">
            <div className="flex justify-between items-center mb-4">
              <h2 className="text-xl font-bold text-slate-800">Your Learning Path</h2>
              <Link href="/dashboard/learn" className="text-cyan-600 hover:text-cyan-700 flex items-center">
                View All
                <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 ml-1" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                </svg>
              </Link>
            </div>
            
            <div className="bg-white rounded-xl p-6 shadow-sm border border-slate-100">
              {profile?.learningLanguages?.length > 0 ? (
                <LearningPath 
                  language={profile.learningLanguages[0].languageCode} 
                  level={profile.learningLanguages[0].proficiencyLevel} 
                  onSelectLesson={(lessonId) => router.push(`/dashboard/learn/${lessonId}`)}
                />
              ) : (
                <div className="text-center py-8">
                  <p className="text-slate-500 mb-4">You haven't set up your learning languages yet.</p>
                  <Link 
                    href="/dashboard/profile" 
                    className="inline-block bg-gradient-to-r from-cyan-500 to-teal-500 text-white px-4 py-2 rounded-lg"
                  >
                    Update Profile
                  </Link>
                </div>
              )}
            </div>
          </div>
        </div>
      </main>
      
      {/* Bottom Navigation */}
      <nav className="fixed bottom-0 left-0 right-0 bg-white border-t border-slate-200 py-2 px-6 z-40">
        <div className="max-w-7xl mx-auto">
          <ul className="flex justify-around">
            <li>
              <Link href="/dashboard" className="flex flex-col items-center text-cyan-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                </svg>
                <span className="text-xs mt-1">Home</span>
              </Link>
            </li>
            <li>
              <Link href="/dashboard/learn" className="flex flex-col items-center text-slate-400 hover:text-cyan-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
                </svg>
                <span className="text-xs mt-1">Learn</span>
              </Link>
            </li>
            <li className="relative">
              <Link href="/dashboard/learn" className="flex flex-col items-center text-slate-700">
                <div className="absolute -top-10 bg-gradient-to-r from-cyan-500 to-teal-500 rounded-full p-3 shadow-lg">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                    <path strokeLinecap="round" strokeLinejoin="round" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                    <path strokeLinecap="round" strokeLinejoin="round" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                  </svg>
                </div>
                <span className="text-xs mt-8">Practice</span>
              </Link>
            </li>
            <li>
              <Link href="/dashboard/challenges" className="flex flex-col items-center text-slate-400 hover:text-cyan-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
                </svg>
                <span className="text-xs mt-1">Challenges</span>
              </Link>
            </li>
            <li>
              <Link href="/dashboard/profile" className="flex flex-col items-center text-slate-400 hover:text-cyan-600">
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
                <span className="text-xs mt-1">Profile</span>
              </Link>
            </li>
          </ul>
        </div>
      </nav>
    </div>
  );
}

// Robot Avatar Component
function RobotAvatar({ size = "medium" }) {
  const sizeClasses = {
    small: "w-10 h-10",
    medium: "w-16 h-16",
    large: "w-24 h-24"
  };
  
  return (
    <div className={`relative ${sizeClasses[size]}`}>
      <div className="relative bg-gradient-to-br from-cyan-400 to-teal-500 rounded-2xl w-full h-full flex items-center justify-center overflow-hidden border-2 border-cyan-300 shadow-md">
        {/* Eyes */}
        <div className="flex space-x-2">
          <div className="bg-yellow-300 rounded-full w-1/4 h-1/4 flex items-center justify-center border border-yellow-400">
            <div className="bg-black rounded-full w-1/2 h-1/2"></div>
          </div>
          <div className="bg-yellow-300 rounded-full w-1/4 h-1/4 flex items-center justify-center border border-yellow-400">
            <div className="bg-black rounded-full w-1/2 h-1/2"></div>
          </div>
        </div>
        
        {/* Antenna */}
        <div className="absolute -top-2 left-1/2 transform -translate-x-1/2">
          <div className="w-1 h-3 bg-slate-600"></div>
          <div className="w-2 h-2 rounded-full bg-red-500 animate-pulse"></div>
        </div>
        
        {/* Mouth */}
        <div className="absolute bottom-2 w-1/2 h-1 bg-slate-700 rounded-full"></div>
      </div>
      
      {/* Shadow effect */}
      <div className="absolute -bottom-1 left-1/2 transform -translate-x-1/2 w-4/5 h-1 bg-black opacity-10 rounded-full blur-sm"></div>
    </div>
  );
}

// Today's Challenge Component
function TodaysChallenge({ challenge, onStart }) {
  const getLanguageFlag = (code) => {
    const flags = {
      ja: "",
      ko: "",
      zh: "",
      en: "",
      es: "",
      fr: "",
      de: "",
      it: "",
      ru: ""
    };
    return flags[code] || "";
  };
  
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="border-b border-slate-100 bg-gradient-to-r from-cyan-50 to-teal-50 px-6 py-4">
        <div className="flex items-center">
          <span className="text-2xl mr-3">{getLanguageFlag(challenge.languageCode)}</span>
          <h2 className="text-xl font-bold text-slate-800">{challenge.title}</h2>
        </div>
      </div>
      
      <div className="p-6">
        <p className="text-slate-600 mb-6">{challenge.description}</p>
        
        <div className="bg-slate-50 rounded-lg p-4 mb-6 border border-slate-100">
          <h3 className="font-medium text-slate-700 mb-2">Today's Exercise:</h3>
          <p className="text-slate-600">{challenge.exercise}</p>
        </div>
        
        <button 
          onClick={onStart}
          className="w-full bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white py-3 px-6 rounded-lg font-medium shadow-md transition-all transform hover:translate-y-[-2px] flex items-center justify-center"
        >
          Start Today's Challenge
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 ml-2" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M10.293 5.293a1 1 0 011.414 0l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414-1.414L12.586 11H5a1 1 0 110-2h7.586l-2.293-2.293a1 1 0 010-1.414z" clipRule="evenodd" />
          </svg>
        </button>
      </div>
    </div>
  );
}

// Learning Stats Component (continued)
function LearningStats({ stats }) {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="border-b border-slate-100 px-6 py-4">
        <h2 className="text-xl font-bold text-slate-800 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M5 2a1 1 0 011 1v1h1a1 1 0 010 2H6v1a1 1 0 01-2 0V6H3a1 1 0 010-2h1V3a1 1 0 011-1zm0 10a1 1 0 011 1v1h1a1 1 0 110 2H6v1a1 1 0 11-2 0v-1H3a1 1 0 110-2h1v-1a1 1 0 011-1zM12 2a1 1 0 01.967.744L14.146 7.2 17.5 9.134a1 1 0 010 1.732l-3.354 1.935-1.18 4.455a1 1 0 01-1.933 0L9.854 12.8 6.5 10.866a1 1 0 010-1.732l3.354-1.935 1.18-4.455A1 1 0 0112 2z" clipRule="evenodd" />
          </svg>
          My Learning Stats
        </h2>
      </div>
      
      <div className="p-6">
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
          <StatCard 
            title="Total Practice" 
            value={`${stats.totalMinutesPracticed || 0} min`} 
            icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-cyan-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>}
            color="cyan"
          />
          
          <StatCard 
            title="Vocabulary" 
            value={`${stats.vocabularySize || 0} words`} 
            icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-purple-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
            </svg>}
            color="purple"
          />
          
          <StatCard 
            title="Current Streak" 
            value={`${stats.currentStreak || 0} days`} 
            icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-amber-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>}
            color="amber"
          />
          
          <StatCard 
            title="Longest Streak" 
            value={`${stats.longestStreak || 0} days`} 
            icon={<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-teal-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={1.5}>
              <path strokeLinecap="round" strokeLinejoin="round" d="M11.933 12.8a1 1 0 000-1.6L6.6 7.2A1 1 0 005 8v8a1 1 0 001.6.8l5.333-4zM19.933 12.8a1 1 0 000-1.6l-5.333-4A1 1 0 0013 8v8a1 1 0 001.6.8l5.333-4z" />
            </svg>}
            color="teal"
          />
        </div>
      </div>
    </div>
  );
}

// Stat Card Component
function StatCard({ title, value, icon, color }) {
  const bgColors = {
    cyan: "bg-cyan-50 border-cyan-100",
    purple: "bg-purple-50 border-purple-100",
    amber: "bg-amber-50 border-amber-100",
    teal: "bg-teal-50 border-teal-100"
  };
  
  const textColors = {
    cyan: "text-cyan-800",
    purple: "text-purple-800",
    amber: "text-amber-800",
    teal: "text-teal-800"
  };
  
  return (
    <div className={`rounded-lg p-4 shadow-sm border flex flex-col ${bgColors[color]}`}>
      <div className="flex justify-between items-start mb-2">
        <h3 className="text-sm font-medium text-slate-600">{title}</h3>
        {icon}
      </div>
      <div className={`text-xl font-bold mt-auto ${textColors[color]}`}>{value}</div>
    </div>
  );
}

// Activity Chart Component
function ActivityChart({ data }) {
  // Find max value for scaling
  const maxMinutes = Math.max(...data.map(d => d.minutes), 10); // Min of 10 for scale
  
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="border-b border-slate-100 px-6 py-4">
        <h2 className="text-xl font-bold text-slate-800 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
            <path d="M2 11a1 1 0 011-1h2a1 1 0 011 1v5a1 1 0 01-1 1H3a1 1 0 01-1-1v-5zM8 7a1 1 0 011-1h2a1 1 0 011 1v9a1 1 0 01-1 1H9a1 1 0 01-1-1V7zM14 4a1 1 0 011-1h2a1 1 0 011 1v12a1 1 0 01-1 1h-2a1 1 0 01-1-1V4z" />
          </svg>
          Weekly Activity
        </h2>
      </div>
      
      <div className="p-6">
        <div className="h-40 flex items-end justify-between">
          {data.map((item, index) => (
            <div key={index} className="flex flex-col items-center">
              <div 
                className={`w-10 rounded-t-md relative ${
                  // Highlight today
                  item.isToday
                    ? 'bg-gradient-to-t from-cyan-400 to-teal-400 border-2 border-amber-400' 
                    : 'bg-gradient-to-t from-cyan-400 to-teal-400 opacity-70'
                }`} 
                style={{ height: `${(item.minutes / maxMinutes) * 100}%` }}
              >
                {/* Minutes indicator */}
                <div className="absolute -top-6 left-1/2 transform -translate-x-1/2 text-xs font-medium text-slate-700">
                  {item.minutes}min
                </div>
              </div>
              <div className={`text-xs mt-2 ${item.isToday ? 'font-bold text-slate-800' : 'text-slate-500'}`}>
                {item.day}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// User Profile Card Component
function UserProfileCard({ profile }) {
  const getLanguageName = (code) => {
    const languages = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ru': 'Russian',
      'pt': 'Portuguese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    
    return languages[code] || code;
  };
  
  const getLevelName = (level) => {
    const levels = {
      'BEGINNER': 'Beginner',
      'ELEMENTARY': 'Elementary',
      'INTERMEDIATE': 'Intermediate',
      'ADVANCED': 'Advanced',
      'FLUENT': 'Fluent'
    };
    
    return levels[level] || level;
  };
  
  const getLevelColor = (level) => {
    const colors = {
      'BEGINNER': 'bg-emerald-100 text-emerald-800',
      'ELEMENTARY': 'bg-sky-100 text-sky-800',
      'INTERMEDIATE': 'bg-amber-100 text-amber-800',
      'ADVANCED': 'bg-purple-100 text-purple-800',
      'FLUENT': 'bg-rose-100 text-rose-800'
    };
    
    return colors[level] || 'bg-slate-100 text-slate-800';
  };
  
  if (!profile) {
    return (
      <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden p-6 animate-pulse">
        <div className="h-16 bg-slate-200 rounded mb-4"></div>
        <div className="h-4 bg-slate-200 rounded w-1/2 mb-6"></div>
        <div className="space-y-3">
          <div className="h-12 bg-slate-200 rounded"></div>
          <div className="h-12 bg-slate-200 rounded"></div>
        </div>
      </div>
    );
  }
  
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="bg-gradient-to-r from-cyan-400 to-teal-500 px-6 py-4">
        <div className="flex items-center">
          <div className="w-12 h-12 bg-white rounded-full mr-3 flex items-center justify-center text-xl font-bold text-cyan-600 shadow-md">
            {profile.username?.charAt(0) || 'U'}
          </div>
          <div>
            <h2 className="text-lg font-bold text-white">{profile.username || 'User'}</h2>
            <p className="text-cyan-100 text-sm">
              {profile.walletAddress ? `${profile.walletAddress.slice(0, 6)}...${profile.walletAddress.slice(-4)}` : 'Connect Wallet'}
            </p>
          </div>
        </div>
      </div>
      
      <div className="p-6">
        <h3 className="text-sm font-medium text-slate-500 uppercase tracking-wider mb-3">Learning Languages</h3>
        {profile.learningLanguages && profile.learningLanguages.length > 0 ? (
          <div className="space-y-3 mb-6">
            {profile.learningLanguages.map((lang) => (
              <div key={lang.id || lang.languageCode} className="flex justify-between items-center bg-slate-50 rounded-lg p-3 border border-slate-100">
                <div className="flex items-center">
                  <span className="mr-2 text-lg">
                    {lang.languageCode === 'ja' ? '' : 
                     lang.languageCode === 'ko' ? '' : 
                     lang.languageCode === 'zh' ? '' : 
                     lang.languageCode === 'en' ? '' : 
                     lang.languageCode === 'es' ? '' : 
                     lang.languageCode === 'fr' ? '' : 
                     lang.languageCode === 'de' ? '' : 
                     lang.languageCode === 'it' ? '' : 
                     lang.languageCode === 'ru' ? '' : ''}
                  </span>
                  <span className="font-medium text-slate-700">{getLanguageName(lang.languageCode)}</span>
                </div>
                <span className={`text-xs px-2 py-1 rounded-full ${getLevelColor(lang.proficiencyLevel)}`}>
                  {getLevelName(lang.proficiencyLevel)}
                </span>
              </div>
            ))}
          </div>
        ) : (
          <div className="bg-slate-50 rounded-lg p-4 mb-6 border border-slate-100 text-center">
            <p className="text-slate-500 mb-2">No learning languages set up yet.</p>
            <Link href="/dashboard/profile" className="text-cyan-600 hover:text-cyan-700 font-medium">
              Update Profile
            </Link>
          </div>
        )}
        
        <h3 className="text-sm font-medium text-slate-500 uppercase tracking-wider mb-3">Achievements</h3>
        {/* We'll fetch real achievements later, for now showing placeholder badges */}
        <div className="flex flex-wrap gap-2 mb-6">
          <div className="w-10 h-10 bg-gradient-to-br from-amber-400 to-amber-500 rounded-full flex items-center justify-center shadow-sm" title="5-Day Streak">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
              <path d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" />
            </svg>
          </div>
          <div className="w-10 h-10 bg-gradient-to-br from-sky-400 to-sky-500 rounded-full flex items-center justify-center shadow-sm" title="100 Words Learned">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
              <path d="M9 4.804A7.968 7.968 0 005.5 4c-1.255 0-2.443.29-3.5.804v10A7.969 7.969 0 015.5 14c1.669 0 3.218.51 4.5 1.385A7.962 7.962 0 0114.5 14c1.255 0 2.443.29 3.5.804v-10A7.968 7.968 0 0014.5 4c-1.255 0-2.443.29-3.5.804V12a1 1 0 11-2 0V4.804z" />
            </svg>
          </div>
          <div className="w-10 h-10 bg-gradient-to-br from-emerald-400 to-emerald-500 rounded-full flex items-center justify-center shadow-sm" title="First Challenge Completed">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
            </svg>
          </div>
        </div>
        
        <Link href="/dashboard/profile" className="block text-center bg-gradient-to-r from-slate-500 to-slate-600 hover:from-slate-600 hover:to-slate-700 text-white px-4 py-2 rounded-lg transition-colors shadow-sm">
          View Full Profile
        </Link>
      </div>
    </div>
  );
}

// Active Challenges Component
function ActiveChallenges({ challenges, onViewChallenge, onViewAll }) {
  const getLanguageFlag = (code) => {
    const flags = {
      ja: "",
      ko: "",
      zh: "",
      en: "",
      es: "",
      fr: "",
      de: "",
      it: "",
      ru: ""
    };
    return flags[code] || "";
  };
  
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    }).format(amount);
  };
  
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden">
      <div className="border-b border-slate-100 px-6 py-4">
        <h2 className="text-xl font-bold text-slate-800 flex items-center">
          <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2 text-cyan-500" viewBox="0 0 20 20" fill="currentColor">
            <path d="M5 4a2 2 0 012-2h6a2 2 0 012 2v14l-5-2.5L5 18V4z" />
          </svg>
          Active Challenges
        </h2>
      </div>
      
      <div className="p-6">
        {challenges.length > 0 ? (
          <div className="space-y-4">
            {challenges.map((challenge) => (
              <div 
                key={challenge.id} 
                className="bg-slate-50 rounded-lg border border-slate-100 p-4 hover:shadow-md transition-shadow cursor-pointer"
                onClick={() => onViewChallenge(challenge.id)}
              >
                <div className="flex justify-between items-start">
                  <div className="flex items-start">
                    <span className="text-2xl mr-3 mt-1">{getLanguageFlag(challenge.languageCode)}</span>
                    <div>
                      <h3 className="font-medium text-slate-800">{challenge.title}</h3>
                      <div className="flex items-center mt-1">
                        <span className="text-xs px-2 py-0.5 bg-cyan-100 text-cyan-800 rounded-full">
                          {challenge.daysLeft} days left
                        </span>
                        <span className="mx-2 text-slate-300"></span>
                        <span className="text-xs text-slate-500">
                          {challenge.dailyRequirement} min/day
                        </span>
                      </div>
                    </div>
                  </div>
                  <div className="flex flex-col items-end">
                    <span className="text-sm font-medium px-2 py-1 bg-amber-100 text-amber-800 rounded-full">
                      {formatCurrency(challenge.stakeAmount)}
                    </span>
                  </div>
                </div>
                
                <div className="mt-4">
                  <div className="flex justify-between text-sm text-slate-500 mb-1">
                    <span>Progress</span>
                    <span className="font-medium text-slate-700">{challenge.progress}%</span>
                  </div>
                  <div className="w-full bg-slate-200 rounded-full h-2">
                    <div 
                      className="bg-gradient-to-r from-cyan-400 to-teal-500 h-2 rounded-full" 
                      style={{ width: `${challenge.progress}%` }}
                    ></div>
                  </div>
                </div>
              </div>
            ))}
          </div>
        ) : (
          <div className="text-center py-6 bg-slate-50 rounded-lg border border-slate-100">
            <p className="text-slate-500 mb-4">You don't have any active challenges yet.</p>
            <button 
              onClick={() => onViewAll()}
              className="px-4 py-2 bg-cyan-500 text-white rounded-lg hover:bg-cyan-600 transition-colors"
            >
              Browse Challenges
            </button>
          </div>
        )}
        
        <button 
          onClick={onViewAll}
          className="block w-full text-center bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-4 py-2 rounded-lg mt-4 transition-colors shadow-md"
        >
          View All Challenges
        </button>
      </div>
    </div>
  );
}

// Learning Path Component
function LearningPath({ language, level, onSelectLesson }) {
  // Sample learning path data - in a real implementation, this would be fetched from the API
  const pathData = [
    { id: 1, title: "Greetings and Introductions", completed: true },
    { id: 2, title: "Basic Conversation", completed: true },
    { id: 3, title: "Restaurant Phrases", current: true },
    { id: 4, title: "Shopping Vocabulary", locked: false },
    { id: 5, title: "Travel Expressions", locked: true },
    { id: 6, title: "Business Japanese", locked: true }
  ];
  
  return (
    <div>
      <div className="flex justify-between items-center mb-6">
        <h3 className="font-bold text-slate-800 flex items-center">
          <span className="mr-2 text-xl">
            {language === 'ja' ? '' : 
             language === 'ko' ? '' : 
             language === 'zh' ? '' : ''}
          </span>
          {language === 'ja' ? 'Japanese' : 
           language === 'ko' ? 'Korean' : 
           language === 'zh' ? 'Chinese' : 'Language'} Learning Path
        </h3>
        <span className="text-xs px-2 py-1 bg-amber-100 text-amber-800 rounded-full">
          {level === 'BEGINNER' ? 'Beginner' :
           level === 'ELEMENTARY' ? 'Elementary' :
           level === 'INTERMEDIATE' ? 'Intermediate' :
           level === 'ADVANCED' ? 'Advanced' :
           level === 'FLUENT' ? 'Fluent' : level}
        </span>
      </div>
      
      <div className="relative">
        {/* Connecting line */}
        <div className="absolute top-0 bottom-0 left-5 w-0.5 bg-slate-200"></div>
        
        {/* Path items */}
        <div className="space-y-6 relative">
          {pathData.map((item) => (
            <div key={item.id} className="flex">
              <div className={`h-10 w-10 rounded-full flex items-center justify-center z-10 mr-4 shadow-sm ${
                item.completed ? 'bg-gradient-to-br from-emerald-400 to-emerald-500' : 
                item.current ? 'bg-gradient-to-br from-amber-400 to-amber-500' : 
                item.locked ? 'bg-gradient-to-br from-slate-300 to-slate-400' : 'bg-gradient-to-br from-cyan-400 to-cyan-500'
              }`}>
                {item.completed ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clipRule="evenodd" />
                  </svg>
                ) : item.current ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z" clipRule="evenodd" />
                  </svg>
                ) : item.locked ? (
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z" clipRule="evenodd" />
                  </svg>
                ) : (
                  <span className="text-white font-medium">{item.id}</span>
                )}
              </div>
              
              <div className={`flex-1 p-4 rounded-lg shadow-sm ${
                item.current ? 'bg-gradient-to-r from-amber-50 to-orange-50 border-2 border-amber-300' : 
                item.locked ? 'bg-slate-50 border border-slate-200 opacity-60' : 'bg-white border border-slate-200'
              }`}>
                <div className="flex justify-between items-center">
                  <h4 className={`font-medium ${item.locked ? 'text-slate-400' : 'text-slate-800'}`}>
                    {item.title}
                  </h4>
                  {item.current && (
                    <span className="text-xs bg-amber-400 text-amber-900 px-2 py-0.5 rounded-full font-medium">
                      Current
                    </span>
                  )}
                </div>
                
                {!item.locked && (
                  <div className="mt-2">
                    <button 
                      onClick={() => onSelectLesson(item.id)}
                      className={`text-sm ${
                        item.current ? 'text-amber-600 hover:text-amber-700' : 'text-cyan-600 hover:text-cyan-700'
                      } hover:underline flex items-center font-medium`}
                    >
                      {item.completed ? 'Review' : 'Start'} Lesson
                      <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 ml-1" viewBox="0 0 20 20" fill="currentColor">
                        <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
                      </svg>
                    </button>
                  </div>
                )}
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// Loading Screen Component
function LoadingScreen() {
  return (
    <div className="min-h-screen bg-slate-50 flex flex-col items-center justify-center p-4">
      <div className="mb-8 animate-bounce">
        <RobotAvatar size="large" />
      </div>
      
      <h1 className="text-2xl font-bold mb-2 text-slate-800">Loading ShinobiSpeak...</h1>
      <p className="text-slate-500 mb-8">Preparing your language learning adventure</p>
      
      <div className="w-64 h-2 bg-slate-200 rounded-full overflow-hidden">
        <div className="h-full bg-gradient-to-r from-cyan-400 to-teal-500 animate-loading-bar"></div>
      </div>
      
      <style jsx>{`
        @keyframes loading {
          0% { width: 0%; }
          50% { width: 70%; }
          100% { width: 100%; }
        }
        .animate-loading-bar {
          animation: loading 2s infinite;
        }
      `}</style>
    </div>
  );
}

================
File: app/globals.css
================
@import "tailwindcss";
@import "tw-animate-css";


:root {
  --foreground-rgb: 51, 65, 85;
  --background-rgb: 248, 250, 252;
}

body {
  color: rgb(var(--foreground-rgb));
  background: rgb(var(--background-rgb));
  min-height: 100vh;
}

/* Custom Animations */
@keyframes float {
  0% { transform: translateY(0px); }
  50% { transform: translateY(-10px); }
  100% { transform: translateY(0px); }
}

.animate-float {
  animation: float 3s ease-in-out infinite;
}

@keyframes loading {
  0% { width: 0%; }
  50% { width: 70%; }
  100% { width: 100%; }
}

.animate-loading-bar {
  animation: loading 2s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

@keyframes bounce {
  0%, 100% { transform: translateY(0); }
  50% { transform: translateY(-25px); }
}

.animate-bounce {
  animation: bounce 1s infinite;
}

/* Tailwind component classes */
@layer components {
  /* Buttons */
  .btn-primary {
    @apply bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-4 py-2 rounded-lg shadow-md transition-all transform hover:translate-y-[-2px];
  }
  
  .btn-secondary {
    @apply bg-white hover:bg-slate-50 border border-slate-200 text-slate-700 px-4 py-2 rounded-lg shadow-sm transition-colors;
  }
  
  .btn-tertiary {
    @apply bg-gradient-to-r from-slate-500 to-slate-600 hover:from-slate-600 hover:to-slate-700 text-white px-4 py-2 rounded-lg shadow-sm transition-colors;
  }
  
  /* Cards */
  .card {
    @apply bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden;
  }
  
  .card-header {
    @apply border-b border-slate-100 px-6 py-4;
  }
  
  .card-body {
    @apply p-6;
  }
  
  .card-footer {
    @apply border-t border-slate-100 px-6 py-4;
  }
  
  /* Stats */
  .stat-card-cyan {
    @apply rounded-lg p-4 shadow-sm border bg-cyan-50 border-cyan-100;
  }
  
  .stat-card-purple {
    @apply rounded-lg p-4 shadow-sm border bg-purple-50 border-purple-100;
  }
  
  .stat-card-amber {
    @apply rounded-lg p-4 shadow-sm border bg-amber-50 border-amber-100;
  }
  
  .stat-card-teal {
    @apply rounded-lg p-4 shadow-sm border bg-teal-50 border-teal-100;
  }
  
  /* Badges */
  .badge {
    @apply text-xs px-2 py-1 rounded-full font-medium;
  }
  
  .badge-primary {
    @apply bg-cyan-100 text-cyan-800;
  }
  
  .badge-secondary {
    @apply bg-amber-100 text-amber-800;
  }
  
  .badge-success {
    @apply bg-emerald-100 text-emerald-800;
  }
  
  .badge-danger {
    @apply bg-rose-100 text-rose-800;
  }
  
  /* Progress bars */
  .progress-bar {
    @apply w-full bg-slate-200 rounded-full h-2 overflow-hidden;
  }
  
  .progress-bar-value {
    @apply h-full rounded-full;
  }
  
  .progress-cyan {
    @apply bg-gradient-to-r from-cyan-400 to-teal-500;
  }
  
  /* Navigation */
  .nav-link {
    @apply flex flex-col items-center text-slate-400 hover:text-cyan-600 transition-colors;
  }
  
  .nav-link-active {
    @apply flex flex-col items-center text-cyan-600;
  }
  
  .practice-button {
    @apply absolute -top-10 bg-gradient-to-r from-cyan-500 to-teal-500 rounded-full p-3 shadow-lg z-10;
  }
}

================
File: app/layout.js
================
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({ children }) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}

================
File: app/page.js
================
// app/page.jsx
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { useRouter } from 'next/navigation';

export default function LandingPage() {
  const router = useRouter();
  const [isScrolled, setIsScrolled] = useState(false);
  const [currentLanguage, setCurrentLanguage] = useState(0);
  const languages = ['Japanese', 'Korean', 'Spanish', 'French', 'Chinese'];
  const languageEmojis = ['', '', '', '', ''];
  
  // Handle scroll events for navbar styling
  useEffect(() => {
    const handleScroll = () => {
      setIsScrolled(window.scrollY > 10);
    };
    
    window.addEventListener('scroll', handleScroll);
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // Rotate through languages for animation
  useEffect(() => {
    const interval = setInterval(() => {
      setCurrentLanguage((prev) => (prev + 1) % languages.length);
    }, 2000);
    
    return () => clearInterval(interval);
  }, []);

  return (
    <div className="min-h-screen overflow-x-hidden bg-slate-50">
      {/* Navbar */}
      <nav className={`fixed top-0 left-0 right-0 z-50 transition-all duration-300 ${
        isScrolled ? 'bg-white shadow-md py-2' : 'bg-transparent py-4'
      }`}>
        <div className="container mx-auto px-6 flex justify-between items-center">
          <div className="flex items-center">
            <div className="mr-3">
              <RobotLogo />
            </div>
            <span className="text-xl font-bold bg-gradient-to-r from-cyan-600 to-teal-600 text-transparent bg-clip-text">
              ShinobiSpeak
            </span>
          </div>
          
          <div className="hidden md:flex space-x-8 text-slate-600">
            <Link href="#features" className="hover:text-cyan-600 transition-colors">Features</Link>
            <Link href="#how-it-works" className="hover:text-cyan-600 transition-colors">How It Works</Link>
            <Link href="#testimonials" className="hover:text-cyan-600 transition-colors">Testimonials</Link>
            <Link href="#pricing" className="hover:text-cyan-600 transition-colors">Pricing</Link>
          </div>
          
          <div className="flex items-center space-x-4">
            <Link href="/auth/signin" className="text-cyan-600 hover:text-cyan-700 font-medium">
              Log in
            </Link>
            <Link href="/auth/signin" className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-4 py-2 rounded-lg shadow-md transition-all transform hover:translate-y-[-2px]">
              Get Started
            </Link>
          </div>
        </div>
      </nav>
      
      {/* Hero Section */}
      <section className="pt-32 pb-20 overflow-hidden relative">
        {/* Background elements */}
        <div className="absolute top-0 left-0 w-full h-full overflow-hidden z-0">
          <div className="absolute top-20 right-[10%] w-64 h-64 bg-cyan-300 rounded-full opacity-20 blur-3xl"></div>
          <div className="absolute bottom-20 left-[5%] w-72 h-72 bg-teal-300 rounded-full opacity-20 blur-3xl"></div>
          <div className="absolute top-40 left-[15%] w-48 h-48 bg-amber-300 rounded-full opacity-20 blur-3xl"></div>
        </div>
        
        <div className="container mx-auto px-6 relative z-10">
          <div className="flex flex-col lg:flex-row items-center gap-12">
            <div className="lg:w-1/2">
              <div className="inline-block px-3 py-1 bg-gradient-to-r from-cyan-100 to-teal-100 text-cyan-800 text-sm font-medium rounded-full mb-6">
                Learn languages with crypto incentives 
              </div>
              
              <h1 className="text-4xl md:text-5xl lg:text-6xl font-bold mb-6 leading-tight">
                Master 
                <span className="relative inline-block mx-2 px-2">
                  <span className="absolute inset-0 bg-gradient-to-r from-cyan-200 to-teal-200 rounded-lg -rotate-1"></span>
                  <span className="relative">
                    <span className="animate-fade-in-out">{languages[currentLanguage]}</span>
                    <span className="ml-2">{languageEmojis[currentLanguage]}</span>
                  </span>
                </span>
                <br />with Real Incentives
              </h1>
              
              <p className="text-lg text-slate-600 mb-8 md:pr-6">
                ShinobiSpeak combines AI-powered conversation practice with financial incentives. 
                Stake crypto on your language learning goals and earn rewards for consistent progress.
              </p>
              
              <div className="flex flex-col sm:flex-row gap-4">
                <Link href="/auth/signin" className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white px-6 py-3 rounded-lg font-medium shadow-md transition-all transform hover:translate-y-[-2px] text-center">
                  Start Learning Now
                </Link>
                <Link href="#how-it-works" className="bg-white border border-slate-200 hover:bg-slate-50 text-slate-700 px-6 py-3 rounded-lg font-medium shadow-sm transition-colors text-center">
                  Learn More
                </Link>
              </div>
              
              <div className="mt-8 flex items-center space-x-4">
                <div className="flex -space-x-2">
                  {[...Array(4)].map((_, i) => (
                    <div key={i} className="w-8 h-8 rounded-full bg-gradient-to-r from-cyan-400 to-teal-400 border-2 border-white flex items-center justify-center text-white text-xs font-bold">
                      {['J', 'K', 'S', 'M'][i]}
                    </div>
                  ))}
                </div>
                <div className="text-sm text-slate-600">
                  <span className="font-medium text-slate-800">2,500+</span> language learners already joined
                </div>
              </div>
            </div>
            
            <div className="lg:w-1/2 relative">
              <div className="relative w-full h-[500px]">
                <HeroAnimation />
              </div>
            </div>
          </div>
        </div>
      </section>
      
      {/* Partners Section */}
      <section className="py-8 border-y border-slate-200 bg-white">
        <div className="container mx-auto px-6">
          <p className="text-slate-500 text-center text-sm uppercase font-medium tracking-wider mb-6">
            Trusted by top blockchain and language learning partners
          </p>
          
          <div className="flex flex-wrap justify-center items-center gap-8 md:gap-16">
            <div className="h-8 grayscale opacity-60 hover:grayscale-0 hover:opacity-100 transition-all duration-300">
              <div className="h-full w-28 bg-slate-300 rounded-md"></div>
            </div>
            <div className="h-8 grayscale opacity-60 hover:grayscale-0 hover:opacity-100 transition-all duration-300">
              <div className="h-full w-28 bg-slate-300 rounded-md"></div>
            </div>
            <div className="h-8 grayscale opacity-60 hover:grayscale-0 hover:opacity-100 transition-all duration-300">
              <div className="h-full w-28 bg-slate-300 rounded-md"></div>
            </div>
            <div className="h-8 grayscale opacity-60 hover:grayscale-0 hover:opacity-100 transition-all duration-300">
              <div className="h-full w-28 bg-slate-300 rounded-md"></div>
            </div>
            <div className="h-8 grayscale opacity-60 hover:grayscale-0 hover:opacity-100 transition-all duration-300">
              <div className="h-full w-28 bg-slate-300 rounded-md"></div>
            </div>
          </div>
        </div>
      </section>
      
      {/* Features Section */}
      <section id="features" className="py-20 bg-white">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <div className="inline-block px-3 py-1 bg-gradient-to-r from-amber-100 to-orange-100 text-amber-800 text-sm font-medium rounded-full mb-4">
              Key Features
            </div>
            <h2 className="text-3xl md:text-4xl font-bold mb-4">
              Why ShinobiSpeak is Revolutionary
            </h2>
            <p className="text-slate-600">
              Our platform combines cutting-edge AI with blockchain incentives to create a language learning experience unlike any other.
            </p>
          </div>
          
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M17 8h2a2 2 0 012 2v6a2 2 0 01-2 2h-2v4l-4-4H9a1.994 1.994 0 01-1.414-.586m0 0L11 14h4a2 2 0 002-2V6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2v4l.586-.586z" />
                </svg>
              }
              title="AI Conversation Practice"
              description="Engage in natural conversations with our AI tutors for immersive language practice that adapts to your skill level."
              color="cyan"
            />
            
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
              }
              title="Crypto Staking Rewards"
              description="Stake cryptocurrency on your learning goals and earn rewards for consistent practice and challenge completion."
              color="amber"
            />
            
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
              }
              title="Gamified Challenges"
              description="Join language learning challenges with specific goals, track your progress, and compete with others."
              color="teal"
            />
            
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" />
                </svg>
              }
              title="Personalized Learning Path"
              description="Get a customized learning journey based on your proficiency level, goals, and learning style."
              color="purple"
            />
            
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M11 5.882V19.24a1.76 1.76 0 01-3.417.592l-2.147-6.15M18 13a3 3 0 100-6M5.436 13.683A4.001 4.001 0 017 6h1.832c4.1 0 7.625-1.234 9.168-3v14c-1.543-1.766-5.067-3-9.168-3H7a3.988 3.988 0 01-1.564-.317z" />
                </svg>
              }
              title="Real-time Feedback"
              description="Receive instant feedback on pronunciation, grammar, and vocabulary usage to improve faster."
              color="rose"
            />
            
            <FeatureCard 
              icon={
                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth={2}>
                  <path strokeLinecap="round" strokeLinejoin="round" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                </svg>
              }
              title="Community Learning"
              description="Join a community of language learners, participate in group challenges, and learn together."
              color="emerald"
            />
          </div>
        </div>
      </section>
      
      {/* How It Works Section */}
      <section id="how-it-works" className="py-20 bg-slate-50">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <div className="inline-block px-3 py-1 bg-gradient-to-r from-teal-100 to-emerald-100 text-teal-800 text-sm font-medium rounded-full mb-4">
              Simple Process
            </div>
            <h2 className="text-3xl md:text-4xl font-bold mb-4">
              How ShinobiSpeak Works
            </h2>
            <p className="text-slate-600">
              Our platform makes language learning effective through financial incentives and AI conversation practice.
            </p>
          </div>
          
          <div className="max-w-4xl mx-auto">
            <div className="relative">
              {/* Connecting line */}
              <div className="absolute left-16 top-0 bottom-0 w-1 bg-gradient-to-b from-cyan-500 to-teal-500 hidden md:block"></div>
              
              <div className="space-y-12">
                <ProcessStep 
                  number="1"
                  title="Connect your wallet"
                  description="Sign up with your cryptocurrency wallet to create your account and access the platform features."
                />
                
                <ProcessStep 
                  number="2"
                  title="Choose a language challenge"
                  description="Select a language and proficiency level, then choose a challenge that matches your learning goals."
                />
                
                <ProcessStep 
                  number="3"
                  title="Stake your crypto"
                  description="Commit to your language learning by staking USDC on your selected challenge."
                />
                
                <ProcessStep 
                  number="4"
                  title="Practice with AI tutors"
                  description="Engage in daily conversation practice with our AI tutors to improve your language skills."
                />
                
                <ProcessStep 
                  number="5"
                  title="Track your progress"
                  description="Monitor your learning streak, vocabulary growth, and overall proficiency improvements."
                />
                
                <ProcessStep 
                  number="6"
                  title="Complete challenges & earn rewards"
                  description="Successfully complete challenges to earn back your stake plus additional rewards from generated yield."
                />
              </div>
            </div>
          </div>
        </div>
      </section>
      
      {/* Testimonials Section */}
      <section id="testimonials" className="py-20 bg-white">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <div className="inline-block px-3 py-1 bg-gradient-to-r from-purple-100 to-violet-100 text-purple-800 text-sm font-medium rounded-full mb-4">
              User Stories
            </div>
            <h2 className="text-3xl md:text-4xl font-bold mb-4">
              What Our Users Say
            </h2>
            <p className="text-slate-600">
              Discover how ShinobiSpeak has transformed language learning journeys.
            </p>
          </div>
          
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-8">
            <TestimonialCard 
              quote="The financial incentive really kept me committed to daily practice. I've tried many language apps before, but ShinobiSpeak is the first one I've stuck with for more than a month."
              author="Alex Tanaka"
              title="Learning Japanese"
              avatar="/images/avatar-1.png"
            />
            
            <TestimonialCard 
              quote="Conversation practice with the AI tutor feels remarkably natural. I'm able to practice Spanish in realistic scenarios, which has boosted my confidence when speaking with native speakers."
              author="Maria Rodriguez"
              title="Learning Spanish"
              avatar="/images/avatar-2.png"
            />
            
            <TestimonialCard 
              quote="The challenge system makes language learning feel like a game. I love competing with others and seeing my progress on the leaderboard. Plus, earning rewards is a nice bonus!"
              author="David Kim"
              title="Learning Korean"
              avatar="/images/avatar-3.png"
            />
          </div>
        </div>
      </section>
      
      {/* Pricing Section */}
      <section id="pricing" className="py-20 bg-slate-50">
        <div className="container mx-auto px-6">
          <div className="text-center max-w-3xl mx-auto mb-16">
            <div className="inline-block px-3 py-1 bg-gradient-to-r from-cyan-100 to-blue-100 text-cyan-800 text-sm font-medium rounded-full mb-4">
              Flexible Plans
            </div>
            <h2 className="text-3xl md:text-4xl font-bold mb-4">
              Choose Your Learning Plan
            </h2>
            <p className="text-slate-600">
              Select the plan that best fits your language learning goals and budget.
            </p>
          </div>
          
          <div className="grid md:grid-cols-3 gap-8 max-w-5xl mx-auto">
            <PricingCard 
              title="Basic"
              price="Free"
              description="Perfect for casual learners"
              features={[
                "1 language",
                "10 minutes of AI conversation daily",
                "Basic progress tracking",
                "Community access"
              ]}
              cta="Get Started"
              highlighted={false}
            />
            
            <PricingCard 
              title="Premium"
              price="$14.99"
              period="per month"
              description="Ideal for serious language learners"
              features={[
                "3 languages",
                "Unlimited AI conversation",
                "Advanced progress analytics",
                "No-loss staking challenges",
                "Priority support"
              ]}
              cta="Start Free Trial"
              highlighted={true}
            />
            
            <PricingCard 
              title="Enterprise"
              price="Custom"
              description="For teams and organizations"
              features={[
                "Unlimited languages",
                "Custom challenge creation",
                "Team leaderboards",
                "API access",
                "Dedicated account manager"
              ]}
              cta="Contact Us"
              highlighted={false}
            />
          </div>
        </div>
      </section>
      
      {/* CTA Section */}
      <section className="py-20 bg-gradient-to-r from-cyan-500 to-teal-500 text-white">
        <div className="container mx-auto px-6">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="text-3xl md:text-4xl font-bold mb-6">
              Ready to Transform Your Language Learning?
            </h2>
            <p className="text-xl mb-8 text-cyan-50">
              Join thousands of learners who are achieving their language goals with ShinobiSpeak.
            </p>
            <Link href="/auth/signin" className="inline-block bg-white text-cyan-600 hover:bg-cyan-50 px-8 py-4 rounded-lg font-medium shadow-lg transition-all transform hover:translate-y-[-2px]">
              Start Your Journey Now
            </Link>
          </div>
        </div>
      </section>
      
      {/* Footer */}
      <footer className="bg-slate-900 text-slate-300 py-12">
        <div className="container mx-auto px-6">
          <div className="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-5 gap-8">
            <div className="col-span-2 lg:col-span-2">
              <div className="flex items-center mb-4">
                <div className="mr-3">
                  <RobotLogo dark={true} />
                </div>
                <span className="text-xl font-bold text-white">
                  ShinobiSpeak
                </span>
              </div>
              <p className="mb-4 text-slate-400">
                Revolutionizing language learning with AI and blockchain technology. Practice conversations and earn rewards.
              </p>
              <div className="flex space-x-4">
                <a href="#" className="text-slate-400 hover:text-white transition-colors">
                  <svg className="h-6 w-6" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M24 4.557c-.883.392-1.832.656-2.828.775 1.017-.609 1.798-1.574 2.165-2.724-.951.564-2.005.974-3.127 1.195-.897-.957-2.178-1.555-3.594-1.555-3.179 0-5.515 2.966-4.797 6.045-4.091-.205-7.719-2.165-10.148-5.144-1.29 2.213-.669 5.108 1.523 6.574-.806-.026-1.566-.247-2.229-.616-.054 2.281 1.581 4.415 3.949 4.89-.693.188-1.452.232-2.224.084.626 1.956 2.444 3.379 4.6 3.419-2.07 1.623-4.678 2.348-7.29 2.04 2.179 1.397 4.768 2.212 7.548 2.212 9.142 0 14.307-7.721 13.995-14.646.962-.695 1.797-1.562 2.457-2.549z"></path>
                  </svg>
                </a>
                <a href="#" className="text-slate-400 hover:text-white transition-colors">
                  <svg className="h-6 w-6" fill="currentColor" viewBox="0 0 24 24">
                    <path fillRule="evenodd" d="M12.315 2c2.43 0 2.784.013 3.808.06 1.064.049 1.791.218 2.427.465a4.902 4.902 0 011.772 1.153 4.902 4.902 0 011.153 1.772c.247.636.416 1.363.465 2.427.048 1.067.06 1.407.06 4.123v.08c0 2.643-.012 2.987-.06 4.043-.049 1.064-.218 1.791-.465 2.427a4.902 4.902 0 01-1.153 1.772 4.902 4.902 0 01-1.772 1.153c-.636.247-1.363.416-2.427.465-1.067.048-1.407.06-4.123.06h-.08c-2.643 0-2.987-.012-4.043-.06-1.064-.049-1.791-.218-2.427-.465a4.902 4.902 0 01-1.772-1.153 4.902 4.902 0 01-1.153-1.772c-.247-.636-.416-1.363-.465-2.427-.047-1.024-.06-1.379-.06-3.808v-.63c0-2.43.013-2.784.06-3.808.049-1.064.218-1.791.465-2.427a4.902 4.902 0 011.153-1.772A4.902 4.902 0 015.45 2.525c.636-.247 1.363-.416 2.427-.465C8.901 2.013 9.256 2 11.685 2h.63zm-.081 1.802h-.468c-2.456 0-2.784.011-3.807.058-.975.045-1.504.207-1.857.344-.467.182-.8.398-1.15.748-.35.35-.566.683-.748 1.15-.137.353-.3.882-.344 1.857-.047 1.023-.058 1.351-.058 3.807v.468c0 2.456.011 2.784.058 3.807.045.975.207 1.504.344 1.857.182.466.399.8.748 1.15.35.35.683.566 1.15.748.353.137.882.3 1.857.344 1.054.048 1.37.058 4.041.058h.08c2.597 0 2.917-.01 3.96-.058.976-.045 1.505-.207 1.858-.344.466-.182.8-.398 1.15-.748.35-.35.566-.683.748-1.15.137-.353.3-.882.344-1.857.048-1.055.058-1.37.058-4.041v-.08c0-2.597-.01-2.917-.058-3.96-.045-.976-.207-1.505-.344-1.858a3.097 3.097 0 00-.748-1.15 3.098 3.098 0 00-1.15-.748c-.353-.137-.882-.3-1.857-.344-1.023-.047-1.351-.058-3.807-.058zM12 6.865a5.135 5.135 0 110 10.27 5.135 5.135 0 010-10.27zm0 1.802a3.333 3.333 0 100 6.666 3.333 3.333 0 000-6.666zm5.338-3.205a1.2 1.2 0 110 2.4 1.2 1.2 0 010-2.4z" clipRule="evenodd"></path>
                  </svg>
                </a>
                <a href="#" className="text-slate-400 hover:text-white transition-colors">
                  <svg className="h-6 w-6" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M8.29 20.251c7.547 0 11.675-6.253 11.675-11.675 0-.178 0-.355-.012-.53A8.348 8.348 0 0022 5.92a8.19 8.19 0 01-2.357.646 4.118 4.118 0 001.804-2.27 8.224 8.224 0 01-2.605.996 4.107 4.107 0 00-6.993 3.743 11.65 11.65 0 01-8.457-4.287 4.106 4.106 0 001.27 5.477A4.072 4.072 0 012.8 9.713v.052a4.105 4.105 0 003.292 4.022 4.095 4.095 0 01-1.853.07 4.108 4.108 0 003.834 2.85A8.233 8.233 0 012 18.407a11.616 11.616 0 006.29 1.84"></path>
                  </svg>
                </a>
                <a href="#" className="text-slate-400 hover:text-white transition-colors">
                  <svg className="h-6 w-6" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 2C6.477 2 2 6.484 2 12.017c0 4.425 2.865 8.18 6.839 9.504.5.092.682-.217.682-.483 0-.237-.008-.868-.013-1.703-2.782.605-3.369-1.343-3.369-1.343-.454-1.158-1.11-1.466-1.11-1.466-.908-.62.069-.608.069-.608 1.003.07 1.531 1.032 1.531 1.032.892 1.53 2.341 1.088 2.91.832.092-.647.35-1.088.636-1.338-2.22-.253-4.555-1.113-4.555-4.951 0-1.093.39-1.988 1.029-2.688-.103-.253-.446-1.272.098-2.65 0 0 .84-.27 2.75 1.026A9.564 9.564 0 0112 6.844c.85.004 1.705.115 2.504.337 1.909-1.296 2.747-1.027 2.747-1.027.546 1.379.202 2.398.1 2.651.64.7 1.028 1.595 1.028 2.688 0 3.848-2.339 4.695-4.566 4.943.359.309.678.92.678 1.855 0 1.338-.012 2.419-.012 2.747 0 .268.18.58.688.482A10.019 10.019 0 0022 12.017C22 6.484 17.522 2 12 2z"></path>
                  </svg>
                </a>
              </div>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold text-white mb-4">Product</h3>
              <ul className="space-y-3">
                <li><a href="#features" className="hover:text-white transition-colors">Features</a></li>
                <li><a href="#how-it-works" className="hover:text-white transition-colors">How It Works</a></li>
                <li><a href="#pricing" className="hover:text-white transition-colors">Pricing</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Roadmap</a></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold text-white mb-4">Resources</h3>
              <ul className="space-y-3">
                <li><a href="#" className="hover:text-white transition-colors">Documentation</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Blog</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Community</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Support</a></li>
              </ul>
            </div>
            
            <div>
              <h3 className="text-lg font-semibold text-white mb-4">Company</h3>
              <ul className="space-y-3">
                <li><a href="#" className="hover:text-white transition-colors">About Us</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Careers</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Privacy Policy</a></li>
                <li><a href="#" className="hover:text-white transition-colors">Terms of Service</a></li>
              </ul>
            </div>
          </div>
          
          <div className="mt-12 pt-8 border-t border-slate-800 text-center text-slate-400">
            <p>&copy; {new Date().getFullYear()} ShinobiSpeak. All rights reserved.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}

// Robot Logo Component
function RobotLogo({ dark = false }) {
  return (
    <div className="w-10 h-10 relative">
      <div className={`relative ${dark ? 'bg-gradient-to-br from-cyan-500 to-teal-600' : 'bg-gradient-to-br from-cyan-400 to-teal-500'} rounded-xl w-full h-full flex items-center justify-center overflow-hidden border-2 ${dark ? 'border-teal-400' : 'border-cyan-300'} shadow-md`}>
        {/* Eyes */}
        <div className="flex space-x-1">
          <div className="bg-yellow-300 rounded-full w-[20%] h-[20%] flex items-center justify-center border border-yellow-400">
            <div className="bg-black rounded-full w-[50%] h-[50%]"></div>
          </div>
          <div className="bg-yellow-300 rounded-full w-[20%] h-[20%] flex items-center justify-center border border-yellow-400">
            <div className="bg-black rounded-full w-[50%] h-[50%]"></div>
          </div>
        </div>
        
        {/* Antenna */}
        <div className="absolute -top-1 left-1/2 transform -translate-x-1/2">
          <div className="w-[2px] h-[5px] bg-slate-600"></div>
          <div className="w-[4px] h-[4px] rounded-full bg-red-500 animate-pulse"></div>
        </div>
        
        {/* Mouth */}
        <div className="absolute bottom-[15%] w-[40%] h-[2px] bg-slate-700 rounded-full"></div>
      </div>
    </div>
  );
}

// Hero Animation Component
function HeroAnimation() {
  return (
    <div className="relative w-full h-full">
      {/* Main image */}
      <div className="absolute w-[80%] h-[80%] top-[10%] left-[10%] rounded-2xl bg-white shadow-xl overflow-hidden border border-slate-200">
        <div className="p-6">
          {/* Robot Avatar and chat interface mockup */}
          <div className="flex">
            <div className="mr-4 flex-shrink-0">
              <div className="w-16 h-16 bg-gradient-to-br from-cyan-400 to-teal-500 rounded-2xl flex items-center justify-center border-2 border-cyan-300 shadow-md">
                <div className="flex space-x-1">
                  <div className="bg-yellow-300 rounded-full w-3 h-3"></div>
                  <div className="bg-yellow-300 rounded-full w-3 h-3"></div>
                </div>
              </div>
            </div>
            <div className="bg-slate-100 rounded-2xl p-4 rounded-tl-none max-w-[70%]">
              <p className="text-slate-800"></p>
              <p className="text-xs text-slate-500 mt-2">Hello! Let's practice ordering at a restaurant. Try ordering a drink.</p>
            </div>
          </div>
          
          {/* User response mockup */}
          <div className="flex justify-end mt-4">
            <div className="bg-cyan-100 rounded-2xl p-4 rounded-tr-none max-w-[70%]">
              <p className="text-slate-800"></p>
              <div className="flex justify-between items-center mt-2">
                <p className="text-xs text-slate-500">I would like a coffee, please.</p>
                <div className="text-xs text-green-600 font-medium flex items-center">
                  <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor">
                    <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
                  </svg>
                  Correct
                </div>
              </div>
            </div>
          </div>
          
          {/* Progress display mockup */}
          <div className="mt-8">
            <div className="flex justify-between text-sm text-slate-600 mb-2">
              <p>Daily Goal: 15/20 minutes</p>
              <p>75% Complete</p>
            </div>
            <div className="w-full bg-slate-200 rounded-full h-2">
              <div className="bg-gradient-to-r from-cyan-400 to-teal-500 h-2 rounded-full w-[75%]"></div>
            </div>
          </div>
          
          {/* Stats mockup */}
          <div className="mt-8 grid grid-cols-3 gap-4">
            <div className="bg-slate-50 rounded-lg p-3 border border-slate-200">
              <p className="text-xs text-slate-500">Current Streak</p>
              <p className="text-lg font-bold text-slate-800">12 days</p>
            </div>
            <div className="bg-slate-50 rounded-lg p-3 border border-slate-200">
              <p className="text-xs text-slate-500">Vocab Learned</p>
              <p className="text-lg font-bold text-slate-800">728 words</p>
            </div>
            <div className="bg-slate-50 rounded-lg p-3 border border-slate-200">
              <p className="text-xs text-slate-500">USDC Staked</p>
              <p className="text-lg font-bold text-slate-800">$200</p>
            </div>
          </div>
        </div>
      </div>
      
      {/* Decorative elements */}
      <div className="absolute top-[5%] right-[5%] w-28 h-28 rounded-full bg-amber-100 animate-float-slow"></div>
      <div className="absolute bottom-[15%] left-[0%] w-20 h-20 rounded-full bg-cyan-100 animate-float"></div>
      
      {/* Stats Cards Floating */}
      <div className="absolute top-[15%] right-[-5%] bg-white rounded-lg shadow-lg p-4 border border-slate-100 animate-float">
        <div className="flex items-center">
          <div className="mr-3 p-2 bg-amber-100 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-amber-600" viewBox="0 0 20 20" fill="currentColor">
              <path d="M13 10V3L4 14h7v7l9-11h-7z" />
            </svg>
          </div>
          <div>
            <p className="text-sm text-slate-500">Current Streak</p>
            <p className="text-lg font-bold text-slate-800">12 days</p>
          </div>
        </div>
      </div>
      
      <div className="absolute bottom-[10%] right-[10%] bg-white rounded-lg shadow-lg p-4 border border-slate-100 animate-float delay-150">
        <div className="flex items-center">
          <div className="mr-3 p-2 bg-teal-100 rounded-full">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-teal-600" viewBox="0 0 20 20" fill="currentColor">
              <path d="M8.433 7.418c.155-.103.346-.196.567-.267v1.698a2.305 2.305 0 01-.567-.267C8.07 8.34 8 8.114 8 8c0-.114.07-.34.433-.582zM11 12.849v-1.698c.22.071.412.164.567.267.364.243.433.468.433.582 0 .114-.07.34-.433.582a2.305 2.305 0 01-.567.267z" />
              <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-13a1 1 0 10-2 0v.092a4.535 4.535 0 00-1.676.662C6.602 6.234 6 7.009 6 8c0 .99.602 1.765 1.324 2.246.48.32 1.054.545 1.676.662v1.941c-.391-.127-.68-.317-.843-.504a1 1 0 10-1.51 1.31c.562.649 1.413 1.076 2.353 1.253V15a1 1 0 102 0v-.092a4.535 4.535 0 001.676-.662C13.398 13.766 14 12.991 14 12c0-.99-.602-1.765-1.324-2.246A4.535 4.535 0 0011 9.092V7.151c.391.127.68.317.843.504a1 1 0 101.511-1.31c-.563-.649-1.413-1.076-2.354-1.253V5z" clipRule="evenodd" />
            </svg>
          </div>
          <div>
            <p className="text-sm text-slate-500">Potential Reward</p>
            <p className="text-lg font-bold text-slate-800">$220 USDC</p>
          </div>
        </div>
      </div>
    </div>
  );
}

// Feature Card Component
function FeatureCard({ icon, title, description, color }) {
  const colors = {
    cyan: "from-cyan-50 to-cyan-100 border-cyan-200 text-cyan-600",
    teal: "from-teal-50 to-teal-100 border-teal-200 text-teal-600",
    amber: "from-amber-50 to-amber-100 border-amber-200 text-amber-600",
    purple: "from-purple-50 to-purple-100 border-purple-200 text-purple-600",
    rose: "from-rose-50 to-rose-100 border-rose-200 text-rose-600",
    emerald: "from-emerald-50 to-emerald-100 border-emerald-200 text-emerald-600"
  };
  
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 overflow-hidden hover:shadow-md transition-shadow">
      <div className={`p-6 border-b border-slate-100 bg-gradient-to-r ${colors[color]}`}>
        <div className="w-12 h-12 rounded-full bg-white flex items-center justify-center shadow-sm mb-4">
          <div className={`text-${color}-600`}>{icon}</div>
        </div>
        <h3 className="text-xl font-bold text-slate-800 mb-2">{title}</h3>
        <p className="text-slate-600">{description}</p>
      </div>
      <div className="p-6 bg-white">
        <Link href="#" className={`text-${color}-600 hover:text-${color}-700 font-medium flex items-center`}>
          Learn more
          <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 ml-1" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clipRule="evenodd" />
          </svg>
        </Link>
      </div>
    </div>
  );
}

// Process Step Component
function ProcessStep({ number, title, description }) {
  return (
    <div className="flex items-start md:items-center">
      <div className="flex-shrink-0 w-12 h-12 rounded-full bg-gradient-to-r from-cyan-500 to-teal-500 text-white flex items-center justify-center font-bold text-lg z-10 shadow-md">
        {number}
      </div>
      <div className="ml-6">
        <h3 className="text-xl font-bold text-slate-800 mb-2">{title}</h3>
        <p className="text-slate-600">{description}</p>
      </div>
    </div>
  );
}

// Testimonial Card Component
function TestimonialCard({ quote, author, title, avatar }) {
  return (
    <div className="bg-white rounded-xl shadow-sm border border-slate-100 p-6 hover:shadow-md transition-shadow h-full flex flex-col">
      <div className="flex-1">
        <svg className="h-8 w-8 text-slate-300 mb-4" fill="currentColor" viewBox="0 0 32 32">
          <path d="M9.352 4C4.456 7.456 1 13.12 1 19.36c0 5.088 3.072 8.064 6.624 8.064 3.36 0 5.856-2.688 5.856-5.856 0-3.168-2.208-5.472-5.088-5.472-.576 0-1.344.096-1.536.192.48-3.264 3.552-7.104 6.624-9.024L9.352 4zm16.512 0c-4.8 3.456-8.256 9.12-8.256 15.36 0 5.088 3.072 8.064 6.624 8.064 3.264 0 5.856-2.688 5.856-5.856 0-3.168-2.304-5.472-5.184-5.472-.576 0-1.248.096-1.44.192.48-3.264 3.456-7.104 6.528-9.024L25.864 4z" />
        </svg>
        <p className="text-slate-600 italic mb-4">{quote}</p>
      </div>
      <div className="flex items-center">
        <div className="mr-3">
          {avatar ? (
            <Image src={avatar} alt={author} width={40} height={40} className="rounded-full" />
          ) : (
            <div className="w-10 h-10 rounded-full bg-slate-200 flex items-center justify-center text-slate-500 font-medium">
              {author.charAt(0)}
            </div>
          )}
        </div>
        <div>
          <h4 className="font-medium text-slate-800">{author}</h4>
          <p className="text-sm text-slate-500">{title}</p>
        </div>
      </div>
    </div>
  );
}

// Pricing Card Component
function PricingCard({ title, price, period, description, features, cta, highlighted }) {
  return (
    <div className={`rounded-xl overflow-hidden ${
      highlighted 
        ? 'bg-white border-2 border-cyan-500 shadow-lg relative transform -translate-y-4' 
        : 'bg-white border border-slate-100 shadow-sm'
    }`}>
      {highlighted && (
        <div className="bg-gradient-to-r from-cyan-500 to-teal-500 text-white text-center py-1 text-sm font-medium">
          Most Popular
        </div>
      )}
      
      <div className="p-6">
        <h3 className="text-xl font-bold text-slate-800 mb-2">{title}</h3>
        <div className="mb-4">
          <span className="text-3xl font-bold text-slate-800">{price}</span>
          {period && <span className="text-slate-500 text-sm ml-1">{period}</span>}
        </div>
        <p className="text-slate-600 mb-6">{description}</p>
        
        <ul className="space-y-3 mb-6">
          {features.map((feature, index) => (
            <li key={index} className="flex items-start">
              <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-green-500 mr-2 flex-shrink-0 mt-0.5" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clipRule="evenodd" />
              </svg>
              <span className="text-slate-600">{feature}</span>
            </li>
          ))}
        </ul>
        
        <Link href="/auth/signin" className={`block text-center py-3 px-6 rounded-lg font-medium transition-colors ${
          highlighted
            ? 'bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 text-white shadow-md'
            : 'bg-white border border-slate-200 hover:bg-slate-50 text-slate-800'
        }`}>
          {cta}
        </Link>
      </div>
    </div>
  );
}

// Add this style to your globals.css
const additionalGlobalStyles = `
  @keyframes fade-in-out {
    0%, 100% { opacity: 0; }
    20%, 80% { opacity: 1; }
  }
  
  .animate-fade-in-out {
    animation: fade-in-out 2s ease-in-out infinite;
  }
  
  @keyframes float-slow {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-20px); }
  }
  
  .animate-float-slow {
    animation: float-slow 6s ease-in-out infinite;
  }
  
  .delay-150 {
    animation-delay: 150ms;
  }
`;

================
File: components/auth/LogoutButton.jsx
================
'use client';

import { useRouter } from 'next/navigation';

export default function LogoutButton({ className }) {
  const router = useRouter();
  
  const handleLogout = async () => {
    try {
      // Call the logout API endpoint
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
      });
      
      if (response.ok) {
        // Redirect to home page after successful logout
        router.push('/');
      } else {
        console.error('Logout failed');
      }
    } catch (error) {
      console.error('Error during logout:', error);
    }
  };
  
  return (
    <button
      onClick={handleLogout}
      className={className || "text-gray-700 hover:text-gray-900"}
    >
      Sign Out
    </button>
  );
}

================
File: components/auth/UserProfileForm.jsx
================
// components/auth/UserProfileForm.jsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';

const LANGUAGES = [
  { code: 'en', name: 'English' },
  { code: 'es', name: 'Spanish' },
  { code: 'fr', name: 'French' },
  { code: 'de', name: 'German' },
  { code: 'it', name: 'Italian' },
  { code: 'ja', name: 'Japanese' },
  { code: 'ko', name: 'Korean' },
  { code: 'zh', name: 'Chinese' },
  { code: 'ru', name: 'Russian' },
  { code: 'pt', name: 'Portuguese' },
  { code: 'ar', name: 'Arabic' },
  { code: 'hi', name: 'Hindi' },
];

export default function UserProfileForm({ walletAddress, onSuccess, onError }) {
  const router = useRouter();
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const [formData, setFormData] = useState({
    username: '',
    email: '',
    nativeLanguage: '',
    learningLanguages: [{ languageCode: '', proficiencyLevel: 'BEGINNER' }]
  });
  
  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData(prev => ({ ...prev, [name]: value }));
  };
  
  const handleLearningLanguageChange = (index, field, value) => {
    setFormData(prev => {
      const newLearningLanguages = [...prev.learningLanguages];
      newLearningLanguages[index] = {
        ...newLearningLanguages[index],
        [field]: value
      };
      return { ...prev, learningLanguages: newLearningLanguages };
    });
  };
  
  const addLearningLanguage = () => {
    setFormData(prev => ({
      ...prev,
      learningLanguages: [
        ...prev.learningLanguages,
        { languageCode: '', proficiencyLevel: 'BEGINNER' }
      ]
    }));
  };
  
  const removeLearningLanguage = (index) => {
    setFormData(prev => {
      const newLearningLanguages = [...prev.learningLanguages];
      newLearningLanguages.splice(index, 1);
      return { ...prev, learningLanguages: newLearningLanguages };
    });
  };
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    // Validate form
    if (!formData.username || !formData.email || !formData.nativeLanguage) {
      onError('Please fill in all required fields');
      return;
    }
    
    if (formData.learningLanguages.some(lang => !lang.languageCode)) {
      onError('Please select all learning languages');
      return;
    }
    
    try {
      setIsSubmitting(true);
      
      const response = await fetch('/api/users/profile', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to update profile');
      }
      
      // Profile update successful
      onSuccess();
      router.push('/dashboard');
    } catch (error) {
      console.error('Profile update error:', error);
      onError(error.message || 'Failed to update profile');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-6 max-w-md mx-auto">
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Wallet Address
        </label>
        <input
          type="text"
          value={walletAddress}
          disabled
          className="w-full px-4 py-2 border border-gray-300 rounded-md bg-gray-100"
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Username*
        </label>
        <input
          type="text"
          name="username"
          value={formData.username}
          onChange={handleChange}
          required
          className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-primary focus:border-transparent"
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Email*
        </label>
        <input
          type="email"
          name="email"
          value={formData.email}
          onChange={handleChange}
          required
          className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-primary focus:border-transparent"
        />
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Native Language*
        </label>
        <select
          name="nativeLanguage"
          value={formData.nativeLanguage}
          onChange={handleChange}
          required
          className="w-full px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-primary focus:border-transparent"
        >
          <option value="">Select your native language</option>
          {LANGUAGES.map(language => (
            <option key={language.code} value={language.code}>
              {language.name}
            </option>
          ))}
        </select>
      </div>
      
      <div>
        <label className="block text-sm font-medium text-gray-700 mb-1">
          Languages You Want to Learn*
        </label>
        
        {formData.learningLanguages.map((lang, index) => (
          <div key={index} className="flex gap-2 mb-2">
            <select
              value={lang.languageCode}
              onChange={(e) => handleLearningLanguageChange(index, 'languageCode', e.target.value)}
              required
              className="w-1/2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-primary focus:border-transparent"
            >
              <option value="">Select language</option>
              {LANGUAGES
                .filter(language => language.code !== formData.nativeLanguage)
                .map(language => (
                  <option key={language.code} value={language.code}>
                    {language.name}
                  </option>
                ))}
            </select>
            
            <select
              value={lang.proficiencyLevel}
              onChange={(e) => handleLearningLanguageChange(index, 'proficiencyLevel', e.target.value)}
              className="w-1/2 px-4 py-2 border border-gray-300 rounded-md focus:ring-2 focus:ring-primary focus:border-transparent"
            >
              <option value="BEGINNER">Beginner</option>
              <option value="ELEMENTARY">Elementary</option>
              <option value="INTERMEDIATE">Intermediate</option>
              <option value="ADVANCED">Advanced</option>
              <option value="FLUENT">Fluent</option>
            </select>
            
            {index > 0 && (
              <button
                type="button"
                onClick={() => removeLearningLanguage(index)}
                className="px-3 py-2 bg-red-500 text-white rounded-md hover:bg-red-600"
              >
                
              </button>
            )}
          </div>
        ))}
        
        <button
          type="button"
          onClick={addLearningLanguage}
          className="mt-2 px-4 py-2 bg-gray-200 text-gray-800 rounded-md hover:bg-gray-300"
        >
          Add Another Language
        </button>
      </div>
      
      <div className="pt-4">
        <button
          type="submit"
          disabled={isSubmitting}
          className="w-full px-6 py-3 bg-primary text-white rounded-lg font-medium hover:bg-primary-dark transition-colors"
        >
          {isSubmitting ? 'Saving...' : 'Complete Profile'}
        </button>
      </div>
    </form>
  );
}

================
File: components/auth/WalletConnectButton.jsx
================
// components/auth/WalletConnectButton.jsx
'use client';

import { useState, useEffect } from 'react';
import { getWalletAddress, signMessage } from '@/lib/web3/providers';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';

export default function WalletConnectButton({ onSuccess, onError }) {
  const [isConnecting, setIsConnecting] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState('idle'); // 'idle', 'connecting', 'signing', 'verifying'
  
  // Reset connection if network changes
  useEffect(() => {
    if (typeof window !== 'undefined' && window.ethereum) {
      const handleNetworkChange = () => {
        // Reset connection status if network changes during connection
        if (connectionStatus !== 'idle') {
          setConnectionStatus('idle');
          setIsConnecting(false);
          onError('Network changed. Please try connecting again.');
        }
      };
      
      window.ethereum.on('chainChanged', handleNetworkChange);
      window.ethereum.on('accountsChanged', handleNetworkChange);
      
      return () => {
        window.ethereum.removeListener('chainChanged', handleNetworkChange);
        window.ethereum.removeListener('accountsChanged', handleNetworkChange);
      };
    }
  }, [connectionStatus, onError]);
  
  const handleConnect = async () => {
    try {
      setIsConnecting(true);
      setConnectionStatus('connecting');
      
      // 1. Get wallet address
      const walletAddress = await getWalletAddress();
      setConnectionStatus('signing');
      
      // 2. Get nonce and message to sign
      const nonceResponse = await fetch(`/api/auth/wallet?address=${walletAddress}`);
      if (!nonceResponse.ok) {
        const errorData = await nonceResponse.json();
        throw new Error(errorData.error || 'Failed to get authentication nonce');
      }
      
      const { message } = await nonceResponse.json();
      
      // 3. Sign the message
      const signature = await signMessage(message);
      setConnectionStatus('verifying');
      
      // 4. Verify signature and authenticate
      const authResponse = await fetch('/api/auth/wallet', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ walletAddress, signature }),
      });
      
      const authData = await authResponse.json();
      
      if (!authResponse.ok) {
        throw new Error(authData.error || 'Authentication failed');
      }
      
      // 5. Call onSuccess with data
      onSuccess({
        walletAddress,
        isNewUser: authData.user.isNewUser
      });
    } catch (error) {
      console.error('Wallet connection error:', error);
      
      // Provide more helpful error messages based on error type
      if (error.code === 4001) {
        onError('You rejected the connection request. Please approve the connection in your wallet.');
      } else if (error.message.includes('already pending')) {
        onError('A wallet connection request is already pending. Please check your wallet.');
      } else if (error.message.includes('network')) {
        onError('Network error. Please check your internet connection and try again.');
      } else {
        onError(error.message || 'Failed to connect wallet');
      }
    } finally {
      setIsConnecting(false);
      setConnectionStatus('idle');
    }
  };
  
  const getButtonText = () => {
    switch (connectionStatus) {
      case 'connecting':
        return 'Connecting...';
      case 'signing':
        return 'Please sign message...';
      case 'verifying':
        return 'Verifying signature...';
      default:
        return 'Connect Wallet';
    }
  };
  
  return (
    <button
      onClick={handleConnect}
      disabled={isConnecting}
      className="flex items-center justify-center bg-gradient-to-r from-cyan-500 to-teal-500 text-white py-3 px-6 rounded-lg font-medium hover:from-cyan-600 hover:to-teal-600 transition-colors disabled:opacity-70"
    >
      {isConnecting && <LoadingSpinner size="small" color="white" className="mr-2" />}
      {getButtonText()}
    </button>
  );
}

================
File: components/challenge/CreateChallengeForm.jsx
================
// components/challenge/CreateChallengeForm.jsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import DashboardLayout from '@/components/layout/DashboardLayout';
import { useContract } from '@/lib/web3/hooks/useContract';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import ErrorMessage from '@/components/ui/ErrorMessage';
import TransactionStatus from '@/components/ui/TransactionStatus';

// List of available languages
const LANGUAGES = [
  { code: 'ja', name: 'Japanese' },
  { code: 'ko', name: 'Korean' },
  { code: 'zh', name: 'Chinese' },
  { code: 'en', name: 'English' },
  { code: 'es', name: 'Spanish' },
  { code: 'fr', name: 'French' },
  { code: 'de', name: 'German' },
  { code: 'it', name: 'Italian' },
  { code: 'ru', name: 'Russian' },
  { code: 'pt', name: 'Portuguese' },
  { code: 'ar', name: 'Arabic' },
  { code: 'hi', name: 'Hindi' }
];

// Proficiency level options
const PROFICIENCY_LEVELS = [
  { value: 'BEGINNER', label: 'Beginner' },
  { value: 'ELEMENTARY', label: 'Elementary' },
  { value: 'INTERMEDIATE', label: 'Intermediate' },
  { value: 'ADVANCED', label: 'Advanced' },
  { value: 'FLUENT', label: 'Fluent' }
];

export default function CreateChallengeForm() {
  const router = useRouter();
  const { isConnected, stakingContract } = useContract();
  
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    languageCode: '',
    proficiencyLevel: 'BEGINNER',
    durationDays: 30,
    dailyRequirement: 20,
    stakeAmount: 100,
    yieldPercentage: 5,
    isHardcore: false,
    maxParticipants: 10,
    inviteCode: '',
    autoJoin: false
  });
  
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(false);
  const [transaction, setTransaction] = useState(null);
  const [step, setStep] = useState('form'); // form, submitting, success
  
  // Validate form is completely filled
  const isFormValid = () => {
    const requiredFields = [
      'title',
      'languageCode',
      'proficiencyLevel',
      'durationDays',
      'dailyRequirement',
      'stakeAmount'
    ];
    
    return requiredFields.every(field => {
      const value = formData[field];
      return value !== undefined && value !== null && value !== '';
    });
  };
  
  // Estimate daily commitment
  const getDailyCommitmentLevel = () => {
    const mins = formData.dailyRequirement;
    if (mins <= 10) return { level: 'Easy', color: 'text-green-500' };
    if (mins <= 20) return { level: 'Moderate', color: 'text-amber-500' };
    if (mins <= 40) return { level: 'Challenging', color: 'text-orange-500' };
    return { level: 'Intense', color: 'text-red-500' };
  };
  
  // Calculate potential reward
  const calculatePotentialReward = () => {
    const stake = parseFloat(formData.stakeAmount);
    const yield_pct = parseFloat(formData.yieldPercentage);
    
    if (isNaN(stake) || isNaN(yield_pct)) return 0;
    
    return stake * (1 + (yield_pct / 100));
  };
  
  // Handle form input changes
  const handleChange = (e) => {
    const { name, value, type, checked } = e.target;
    
    setFormData(prev => ({
      ...prev,
      [name]: type === 'checkbox' ? checked : value
    }));
  };
  
  // Handle form submission
  const handleSubmit = async (e) => {
    e.preventDefault();
  
    if (!isFormValid()) {
      setError('Please fill out all required fields');
      return;
    }
    
    setError(null);
    setIsSubmitting(true);
    setStep('submitting');
    
    try {
      let transactionHash = null;
      let contractAddress = null;
      
      // Register on blockchain if connected
      if (isConnected && stakingContract) {
        try {
          // Show detailed progress to user
          setSubmissionProgress({
            step: 'preparing',
            message: 'Preparing contract transaction...'
          });
          
          // Convert values for contract
          const stakeAmount = Math.round(parseFloat(formData.stakeAmount) * 100); // Convert to cents
          const yieldBps = Math.round(parseFloat(formData.yieldPercentage) * 100); // Convert to basis points
          
          // Create a unique challenge ID - use timestamp + random string
          const challengeId = `${Date.now()}-${Math.random().toString(36).substring(2, 10)}`;
          
          setSubmissionProgress({
            step: 'confirming',
            message: 'Please confirm the transaction in your wallet...'
          });
          
          // Call the contract function
          const tx = await stakingContract.registerChallenge(
            challengeId,
            stakeAmount,
            yieldBps,
            formData.isHardcore,
            parseInt(formData.durationDays),
            { gasLimit: 300000 }
          );
          
          setSubmissionProgress({
            step: 'mining',
            message: 'Transaction submitted! Waiting for confirmation...',
            txHash: tx.hash
          });
          
          // Wait for transaction confirmation
          const receipt = await tx.wait();
          
          if (receipt.status) {
            transactionHash = receipt.hash;
            contractAddress = stakingContract.target;
            
            setSubmissionProgress({
              step: 'confirmed',
              message: 'Transaction confirmed! Creating challenge...',
              txHash: receipt.hash
            });
          } else {
            throw new Error('Transaction failed');
          }
        } catch (contractError) {
          console.error('Error registering challenge on blockchain:', contractError);
          
          // Provide more specific error message
          if (contractError.code === 4001) {
            throw new Error('Transaction rejected. Please approve the transaction in your wallet.');
          } else if (contractError.message.includes('gas')) {
            throw new Error('Transaction failed: Gas estimation error. Please try again with different parameters.');
          } else {
            throw new Error(`Blockchain error: ${contractError.message}`);
          }
        }
      }
      
      // Create challenge in database
      const challengeData = {
        ...formData,
        transactionHash,
        contractAddress,
        contractChain: 'polygon' // Or use environment config to determine chain
      };
      
      const response = await fetch('/api/challenges/create', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(challengeData),
      });
      
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to create challenge');
      }
      
      const data = await response.json();
      
      // Store transaction information
      if (transactionHash) {
        setTransaction({
          hash: transactionHash,
          status: 'success'
        });
      }
      
      setSuccess(true);
      setStep('success');
      
      // Redirect after a short delay
      setTimeout(() => {
        router.push(`/dashboard/challenges/${data.id}`);
      }, 3000);
    } catch (error) {
      console.error('Error creating challenge:', error);
      setError(error.message || 'Failed to create challenge');
      setStep('form');
    } finally {
      setIsSubmitting(false);
    }
  };
  
  // Render the form step
  const renderForm = () => (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <ErrorMessage 
          message={error} 
          dismiss={() => setError(null)} 
        />
      )}
      
      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">Challenge Details</h2>
        </div>
        
        <div className="p-6 space-y-6">
          {/* Title */}
          <div>
            <label htmlFor="title" className="block text-sm font-medium text-gray-700">
              Challenge Title*
            </label>
            <input
              type="text"
              id="title"
              name="title"
              value={formData.title}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
              placeholder="e.g., '30-Day Japanese Speaking Challenge'"
              required
            />
          </div>
          
          {/* Description */}
          <div>
            <label htmlFor="description" className="block text-sm font-medium text-gray-700">
              Description
            </label>
            <textarea
              id="description"
              name="description"
              rows={3}
              value={formData.description}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
              placeholder="Describe your challenge and what participants will achieve..."
            />
          </div>
          
          {/* Language and Proficiency */}
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <div>
              <label htmlFor="languageCode" className="block text-sm font-medium text-gray-700">
                Language*
              </label>
              <select
                id="languageCode"
                name="languageCode"
                value={formData.languageCode}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                required
              >
                <option value="">Select a language</option>
                {LANGUAGES.map(lang => (
                  <option key={lang.code} value={lang.code}>
                    {lang.name}
                  </option>
                ))}
              </select>
            </div>
            
            <div>
              <label htmlFor="proficiencyLevel" className="block text-sm font-medium text-gray-700">
                Proficiency Level*
              </label>
              <select
                id="proficiencyLevel"
                name="proficiencyLevel"
                value={formData.proficiencyLevel}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                required
              >
                {PROFICIENCY_LEVELS.map(level => (
                  <option key={level.value} value={level.value}>
                    {level.label}
                  </option>
                ))}
              </select>
            </div>
          </div>
        </div>
      </div>
      
      {/* Challenge Parameters */}
      <div className="bg-white shadow-sm rounded-lg overflow-hidden border border-gray-200">
        <div className="px-6 py-4 border-b border-gray-200">
          <h2 className="text-lg font-medium text-gray-900">Challenge Parameters</h2>
        </div>
        
        <div className="p-6 space-y-6">
          {/* Duration and Daily Requirement */}
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <div>
              <label htmlFor="durationDays" className="block text-sm font-medium text-gray-700">
                Duration (days)*
              </label>
              <input
                type="number"
                id="durationDays"
                name="durationDays"
                min="7"
                max="365"
                value={formData.durationDays}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                required
              />
              <p className="mt-1 text-sm text-gray-500">
                We recommend 30-90 days for optimal results
              </p>
            </div>
            
            <div>
              <label htmlFor="dailyRequirement" className="block text-sm font-medium text-gray-700">
                Daily Practice (minutes)*
              </label>
              <input
                type="number"
                id="dailyRequirement"
                name="dailyRequirement"
                min="5"
                max="120"
                value={formData.dailyRequirement}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                required
              />
              <p className="mt-1 text-sm text-gray-500">
                Commitment level: <span className={getDailyCommitmentLevel().color}>{getDailyCommitmentLevel().level}</span>
              </p>
            </div>
          </div>
          
          {/* Stake Amount and Yield */}
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <div>
              <label htmlFor="stakeAmount" className="block text-sm font-medium text-gray-700">
                Stake Amount (USDC)*
              </label>
              <div className="mt-1 relative rounded-md shadow-sm">
                <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                  <span className="text-gray-500 sm:text-sm">$</span>
                </div>
                <input
                  type="number"
                  id="stakeAmount"
                  name="stakeAmount"
                  min="10"
                  max="1000"
                  value={formData.stakeAmount}
                  onChange={handleChange}
                  className="block w-full pl-7 pr-12 py-2 rounded-md border border-gray-300 focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                  placeholder="0.00"
                  required
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                  <span className="text-gray-500 sm:text-sm">USDC</span>
                </div>
              </div>
              <p className="mt-1 text-sm text-gray-500">
                Minimum stake: $10 USDC
              </p>
            </div>
            
            <div>
              <label htmlFor="yieldPercentage" className="block text-sm font-medium text-gray-700">
                Yield Percentage
              </label>
              <div className="mt-1 relative rounded-md shadow-sm">
                <input
                  type="number"
                  id="yieldPercentage"
                  name="yieldPercentage"
                  min="0"
                  max="20"
                  step="0.5"
                  value={formData.yieldPercentage}
                  onChange={handleChange}
                  className="block w-full pr-12 py-2 rounded-md border border-gray-300 focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
                  placeholder="5"
                />
                <div className="absolute inset-y-0 right-0 pr-3 flex items-center pointer-events-none">
                  <span className="text-gray-500 sm:text-sm">%</span>
                </div>
              </div>
              <p className="mt-1 text-sm text-gray-500">
                Potential reward: ${calculatePotentialReward().toFixed(2)} USDC
              </p>
            </div>
          </div>
          
          {/* Challenge Type and Max Participants */}
          <div className="grid grid-cols-1 gap-6 sm:grid-cols-2">
            <div className="flex items-start">
              <div className="flex items-center h-5">
                <input
                  id="isHardcore"
                  name="isHardcore"
                  type="checkbox"
                  checked={formData.isHardcore}
                  onChange={handleChange}
                  className="focus:ring-cyan-500 h-4 w-4 text-cyan-600 border-gray-300 rounded"
                />
              </div>
              <div className="ml-3 text-sm">
                <label htmlFor="isHardcore" className="font-medium text-gray-700">
                  Hardcore Challenge
                </label>
                <p className="text-gray-500">
                  Stake is forfeited if daily requirements are not met
                </p>
              </div>
            </div>
            
            <div>
              <label htmlFor="maxParticipants" className="block text-sm font-medium text-gray-700">
                Max Participants (optional)
              </label>
              <input
                type="number"
                id="maxParticipants"
                name="maxParticipants"
                min="0"
                max="1000"
                value={formData.maxParticipants}
                onChange={handleChange}
                className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
              />
              <p className="mt-1 text-sm text-gray-500">
                Leave empty for unlimited participants
              </p>
            </div>
          </div>
          
          {/* Invite Code */}
          <div>
            <label htmlFor="inviteCode" className="block text-sm font-medium text-gray-700">
              Private Invite Code (optional)
            </label>
            <input
              type="text"
              id="inviteCode"
              name="inviteCode"
              value={formData.inviteCode}
              onChange={handleChange}
              className="mt-1 block w-full rounded-md border border-gray-300 py-2 px-3 shadow-sm focus:border-cyan-500 focus:outline-none focus:ring-cyan-500"
              placeholder="Leave empty for public challenge"
            />
            <p className="mt-1 text-sm text-gray-500">
              Create a private challenge only accessible via invite code
            </p>
          </div>
          
          {/* Auto-join option */}
          <div className="flex items-start">
            <div className="flex items-center h-5">
              <input
                id="autoJoin"
                name="autoJoin"
                type="checkbox"
                checked={formData.autoJoin}
                onChange={handleChange}
                className="focus:ring-cyan-500 h-4 w-4 text-cyan-600 border-gray-300 rounded"
              />
            </div>
            <div className="ml-3 text-sm">
              <label htmlFor="autoJoin" className="font-medium text-gray-700">
                Join my own challenge
              </label>
              <p className="text-gray-500">
                Automatically join this challenge after creation
              </p>
            </div>
          </div>
        </div>
      </div>
      
      {/* Wallet Connection Notice */}
      {!isConnected && (
        <div className="bg-amber-50 border border-amber-200 rounded-md p-4 text-amber-800">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-amber-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium">Wallet not connected</h3>
              <p className="text-sm mt-1">
                Your challenge will be created without blockchain integration. Connect your wallet to enable staking functionality.
              </p>
            </div>
          </div>
        </div>
      )}
      
      {/* Submit Button */}
      <div className="flex justify-end">
        <button
          type="button"
          onClick={() => router.back()}
          className="bg-white py-2 px-4 border border-gray-300 rounded-md shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-cyan-500 mr-3"
        >
          Cancel
        </button>
        <button
          type="submit"
          disabled={!isFormValid() || isSubmitting}
          className="bg-gradient-to-r from-cyan-500 to-teal-500 hover:from-cyan-600 hover:to-teal-600 border border-transparent rounded-md shadow-sm py-2 px-4 inline-flex justify-center text-sm font-medium text-white focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-cyan-500 disabled:opacity-50"
        >
          Create Challenge
        </button>
      </div>
    </form>
  );
  
  // Render the submitting step
  const renderSubmitting = () => (
    <div className="text-center py-12">
      <LoadingSpinner size="large" />
      <h2 className="mt-4 text-lg font-medium text-gray-900">Creating Your Challenge</h2>
      <p className="mt-2 text-sm text-gray-500">
        Please wait while we set up your challenge...
      </p>
      {isConnected && (
        <p className="mt-1 text-sm text-gray-500">
          This includes registering it on the blockchain, which may take a minute.
        </p>
      )}
    </div>
  );
  
  // Render the success step
  const renderSuccess = () => (
    <div className="text-center py-12">
      <div className="mx-auto flex items-center justify-center h-12 w-12 rounded-full bg-green-100">
        <svg className="h-6 w-6 text-green-600" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" aria-hidden="true">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 13l4 4L19 7" />
        </svg>
      </div>
      <h2 className="mt-4 text-lg font-medium text-gray-900">Challenge Created Successfully!</h2>
      <p className="mt-2 text-sm text-gray-500">
        Your challenge is now ready. Redirecting to challenge details...
      </p>
      
      {transaction && (
        <div className="mt-6 max-w-md mx-auto">
          <TransactionStatus 
            txHash={transaction.hash}
            status={transaction.status}
            message="Blockchain transaction completed"
          />
        </div>
      )}
    </div>
  );
  
  return (
    <DashboardLayout>
      <div className="py-8">
        <div className="max-w-3xl mx-auto">
          <div className="md:flex md:items-center md:justify-between mb-8">
            <div className="flex-1 min-w-0">
              <h1 className="text-2xl font-bold leading-7 text-gray-900 sm:text-3xl sm:truncate">
                Create New Challenge
              </h1>
              <p className="mt-1 text-sm text-gray-500">
                Set up a new language learning challenge and invite others to join you.
              </p>
            </div>
          </div>
          
          {step === 'form' && renderForm()}
          {step === 'submitting' && renderSubmitting()}
          {step === 'success' && renderSuccess()}
        </div>
      </div>
    </DashboardLayout>
  );
}

================
File: components/challenge/JoinChallengeFlow.jsx
================
'use client';

import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useStaking } from '@/lib/web3/hooks/useStaking';
import { useContract } from '@/lib/web3/hooks/useContract';
import { useYield } from '@/lib/web3/hooks/useYield';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';
import ErrorMessage from '@/components/ui/ErrorMessage';
import TransactionStatus from '@/components/ui/TransactionStatus';

export default function JoinChallengeFlow({ challenge, onSuccess, onCancel }) {
  const router = useRouter();
  const { isConnected, signer } = useContract();
  const { stakeForChallenge, isStaking, stakingError, transaction, stakingSuccess } = useStaking();
  const { projectedReward, apy } = useYield(challenge.stakeAmount, challenge.yieldPercentage, challenge.durationDays);
  
  const [step, setStep] = useState('confirmation'); // confirmation, staking, result
  const [walletAddress, setWalletAddress] = useState('');
  const [error, setError] = useState(null);
  
  // Get connected wallet address
  useEffect(() => {
    const getAddress = async () => {
      if (signer) {
        try {
          const address = await signer.getAddress();
          setWalletAddress(address);
        } catch (err) {
          console.error('Error getting wallet address:', err);
        }
      }
    };
    
    getAddress();
  }, [signer]);
  
  // Handle transaction status changes
  useEffect(() => {
    if (stakingSuccess) {
      setStep('result');
    }
  }, [stakingSuccess]);
  
  // Handle staking errors
  useEffect(() => {
    if (stakingError) {
      setError(stakingError);
    }
  }, [stakingError]);
  
// Enhanced staking function in JoinChallengeFlow.jsx
const handleJoinChallenge = async () => {
  setError(null);
  
  if (!isConnected) {
    setError('Please connect your wallet first');
    return;
  }
  
  try {
    setStep('staking');
    setStakingStage('approving'); // Track substages: 'approving', 'staking', 'confirming'
    
    // 1. First approve USDC spending
    try {
      const approvalTx = await approveUSDC(challenge.stakeAmount);
      setStakingStage('staking');
      console.log('USDC approval confirmed:', approvalTx);
    } catch (approvalError) {
      if (approvalError.code === 4001) {
        throw new Error('You rejected the approval transaction. Please approve USDC spending to continue.');
      }
      throw new Error(`Failed to approve USDC: ${approvalError.message}`);
    }
    
    // 2. Stake for the challenge
    try {
      const stakingTxHash = await stakeForChallenge(
        challenge.id,
        challenge.stakeAmount,
        challenge.isHardcore
      );
      
      if (!stakingTxHash) {
        throw new Error('Failed to stake. Please try again.');
      }
      
      setStakingStage('confirming');
      
      // 3. Register participation on backend
      const joinResponse = await fetch('/api/challenges/join', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          challengeId: challenge.id,
          transactionHash: stakingTxHash
        }),
      });
      
      if (!joinResponse.ok) {
        const errorData = await joinResponse.json();
        throw new Error(errorData.error || 'Failed to join challenge');
      }
      
      const joinData = await joinResponse.json();
      
      // 4. Success - call onSuccess callback with complete data
      if (onSuccess) {
        onSuccess(stakingTxHash, joinData);
      }
    } catch (stakingError) {
      if (stakingError.code === 4001) {
        throw new Error('You rejected the staking transaction. Please approve the transaction to join the challenge.');
      }
      throw stakingError;
    }
  } catch (error) {
    console.error('Error joining challenge:', error);
    setError(error.message || 'Failed to join challenge');
    setStep('confirmation'); // Go back to confirmation step on error
  }
};

  // Format currency
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  };
  
  // Confirmation Step
  const renderConfirmation = () => (
    <div className="space-y-4">
      <h2 className="text-xl font-bold text-gray-900">Confirm Challenge Participation</h2>
      
      {error && (
        <ErrorMessage 
          message={error} 
          dismiss={() => setError(null)} 
        />
      )}
      
      <div className="bg-gray-50 rounded-md p-4 border border-gray-200">
        <h3 className="font-medium">{challenge.title}</h3>
        <p className="text-sm text-gray-500 mt-1">{challenge.description}</p>
        
        <div className="mt-4 space-y-2">
          <div className="flex justify-between">
            <span className="text-sm text-gray-500">Duration:</span>
            <span className="text-sm font-medium">{challenge.durationDays} days</span>
          </div>
          <div className="flex justify-between">
            <span className="text-sm text-gray-500">Daily requirement:</span>
            <span className="text-sm font-medium">{challenge.dailyRequirement} minutes</span>
          </div>
          <div className="flex justify-between">
            <span className="text-sm text-gray-500">Stake amount:</span>
            <span className="text-sm font-medium">{formatCurrency(challenge.stakeAmount)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-sm text-gray-500">Potential reward:</span>
            <span className="text-sm font-medium text-green-600">{formatCurrency(projectedReward)}</span>
          </div>
          <div className="flex justify-between">
            <span className="text-sm text-gray-500">Effective APY:</span>
            <span className="text-sm font-medium text-green-600">{apy.toFixed(2)}%</span>
          </div>
        </div>
      </div>
      
      {challenge.isHardcore && (
        <div className="bg-red-50 p-4 rounded-md text-red-700 border border-red-200">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg className="h-5 w-5 text-red-400" viewBox="0 0 20 20" fill="currentColor">
                <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium">Hardcore Challenge</h3>
              <div className="mt-1 text-sm">
                <p>
                  This is a hardcore challenge. If you fail to meet the daily requirements, your stake will be forfeited.
                  Make sure you're committed before joining.
                </p>
              </div>
            </div>
          </div>
        </div>
      )}
      
      <div className="flex justify-between pt-4">
        <button
          onClick={onCancel}
          className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
        >
          Cancel
        </button>
        <button
          onClick={handleJoinChallenge}
          className="px-4 py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-md hover:from-cyan-600 hover:to-teal-600"
          disabled={!isConnected}
        >
          {isConnected ? 'Join Challenge' : 'Connect Wallet to Join'}
        </button>
      </div>
    </div>
  );
  
  // Staking Step (loading)
  const renderStaking = () => (
    <div className="space-y-6 text-center py-8">
      <LoadingSpinner size="large" />
      <div>
        <h2 className="text-xl font-bold text-gray-900 mb-2">Staking in Progress</h2>
        <p className="text-gray-500">
          Please confirm the transaction in your wallet.<br />
          Do not close this window until the transaction is complete.
        </p>
      </div>
    </div>
  );
  
  // Result Step
  const renderResult = () => (
    <div className="space-y-6">
      <TransactionStatus 
        txHash={transaction?.hash}
        status={transaction?.status || 'success'}
        message={
          transaction?.status === 'success' 
            ? `You've successfully joined the ${challenge.title} challenge!` 
            : 'There was an issue with your transaction.'
        }
      />
      
      <div className="text-center mt-6">
        <p className="mb-4">
          {transaction?.status === 'success' 
            ? "You're all set! Start practicing today to make progress on your challenge." 
            : "Please try again or contact support if the issue persists."}
        </p>
        
        <div className="flex justify-center space-x-4 mt-4">
          {transaction?.status === 'success' ? (
            <>
              <button
                onClick={() => router.push('/dashboard/learn')}
                className="px-4 py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-md hover:from-cyan-600 hover:to-teal-600"
              >
                Start Learning
              </button>
              <button
                onClick={() => router.push('/dashboard/challenges')}
                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
              >
                View My Challenges
              </button>
            </>
          ) : (
            <button
              onClick={() => setStep('confirmation')}
              className="px-4 py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-md hover:from-cyan-600 hover:to-teal-600"
            >
              Try Again
            </button>
          )}
        </div>
      </div>
    </div>
  );
  
  return (
    <div className="bg-white rounded-lg shadow-md p-6 max-w-lg mx-auto">
      {step === 'confirmation' && renderConfirmation()}
      {step === 'staking' && renderStaking()}
      {step === 'result' && renderResult()}
    </div>
  );
}

================
File: components/challenge/YieldInformation.jsx
================
// components/challenge/YieldInformation.jsx
'use client';

import { useState, useEffect } from 'react';
import { useYield } from '@/lib/web3/hooks/useYield';

export default function YieldInformation({ 
  stakedAmount, 
  yieldPercentage, 
  durationDays,
  challengeStartDate,
  isHardcore = false
}) {
  const { projectedReward, dailyYield, apy } = useYield(stakedAmount, yieldPercentage, durationDays);
  const [timeRemaining, setTimeRemaining] = useState('');
  const [earnedToDate, setEarnedToDate] = useState(0);
  const [progress, setProgress] = useState(0);

  useEffect(() => {
    // Calculate time remaining and earned yield to date
    if (challengeStartDate) {
      const updateTimeAndYield = () => {
        const startDate = new Date(challengeStartDate);
        const now = new Date();
        const endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + durationDays);
        
        // Calculate time remaining
        if (now >= endDate) {
          setTimeRemaining('Completed');
          setProgress(100);
        } else {
          const totalMs = endDate - startDate;
          const elapsedMs = now - startDate;
          const remainingMs = endDate - now;
          
          // Calculate progress
          const calculatedProgress = Math.min(100, (elapsedMs / totalMs) * 100);
          setProgress(calculatedProgress);
          
          // Format time remaining
          const days = Math.floor(remainingMs / (1000 * 60 * 60 * 24));
          const hours = Math.floor((remainingMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          setTimeRemaining(`${days}d ${hours}h`);
          
          // Calculate earned yield to date
          const daysPassed = elapsedMs / (1000 * 60 * 60 * 24);
          const earned = dailyYield * Math.min(daysPassed, durationDays);
          setEarnedToDate(earned);
        }
      };
      
      updateTimeAndYield();
      const interval = setInterval(updateTimeAndYield, 60000); // Update every minute
      
      return () => clearInterval(interval);
    }
  }, [challengeStartDate, durationDays, dailyYield]);
  
  // Format currency
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    }).format(amount);
  };
  
  return (
    <div className="bg-white rounded-lg border border-slate-200 p-4 shadow-sm">
      <h3 className="text-lg font-medium text-slate-800 mb-4">Yield Information</h3>
      
      {isHardcore ? (
        <div className="bg-red-50 text-red-700 border border-red-200 rounded-md p-3 mb-4">
          <p className="text-sm font-medium">Hardcore Challenge</p>
          <p className="text-xs">Your stake will be forfeited if you fail to meet the challenge requirements.</p>
        </div>
      ) : (
        <div className="bg-green-50 text-green-700 border border-green-200 rounded-md p-3 mb-4">
          <p className="text-sm font-medium">No-Loss Challenge</p>
          <p className="text-xs">Your stake will be returned even if you don't complete all requirements.</p>
        </div>
      )}
      
      <div className="space-y-3">
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Staked Amount:</span>
          <span className="font-medium">{formatCurrency(stakedAmount)}</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Yield Percentage:</span>
          <span className="font-medium text-green-600">{yieldPercentage}%</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Effective APY:</span>
          <span className="font-medium text-green-600">{apy.toFixed(2)}%</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Duration:</span>
          <span className="font-medium">{durationDays} days</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Time Remaining:</span>
          <span className="font-medium">{timeRemaining}</span>
        </div>
        
        <div className="mt-2 mb-1">
          <div className="flex justify-between text-xs text-slate-500 mb-1">
            <span>Progress</span>
            <span>{Math.round(progress)}%</span>
          </div>
          <div className="w-full bg-slate-200 rounded-full h-2">
            <div 
              className="bg-gradient-to-r from-cyan-400 to-teal-500 h-2 rounded-full" 
              style={{ width: `${progress}%` }}
            ></div>
          </div>
        </div>
        
        <hr className="my-3 border-slate-200" />
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Earned to Date:</span>
          <span className="font-medium text-green-600">{formatCurrency(earnedToDate)}</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Projected Total Reward:</span>
          <span className="font-medium text-green-600">{formatCurrency(projectedReward)}</span>
        </div>
        
        <div className="flex justify-between items-center">
          <span className="text-slate-600 text-sm">Projected Profit:</span>
          <span className="font-medium text-green-600">{formatCurrency(projectedReward - stakedAmount)}</span>
        </div>
      </div>
    </div>
  );
}

================
File: components/dashboard/ChallengeCard.jsx
================
// components/dashboard/ChallengeCard.jsx
import Link from 'next/link';

export default function ChallengeCard({ challenge, isActive }) {
  // Format currency with 2 decimal places
  const formatCurrency = (amount) => {
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 2
    }).format(amount);
  };
  
  // Get language name from language code
  const getLanguageName = (code) => {
    const languages = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ru': 'Russian',
      'pt': 'Portuguese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    
    return languages[code] || code;
  };
  
  // Format proficiency level for display
  const formatProficiencyLevel = (level) => {
    return level.charAt(0) + level.slice(1).toLowerCase();
  };
  
  return (
    <div className="bg-white rounded-lg shadow-md overflow-hidden border border-gray-200">
      {/* Card header with language and level */}
      <div className="bg-gray-50 px-4 py-2 border-b border-gray-200">
        <div className="flex justify-between items-center">
          <span className="font-medium text-gray-600">
            {getLanguageName(challenge.languageCode)}
          </span>
          <span className="bg-blue-100 text-blue-800 text-xs px-2 py-1 rounded-full">
            {formatProficiencyLevel(challenge.proficiencyLevel)}
          </span>
        </div>
      </div>
      
      {/* Card body */}
      <div className="p-4">
        <h3 className="font-bold text-lg mb-2">{challenge.title}</h3>
        <p className="text-gray-600 text-sm mb-4 line-clamp-2">{challenge.description}</p>
        
        {/* Challenge details */}
        <div className="space-y-2 mb-4">
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Duration:</span>
            <span className="font-medium">{challenge.durationDays} days</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Daily requirement:</span>
            <span className="font-medium">{challenge.dailyRequirement} min</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Stake amount:</span>
            <span className="font-medium">{formatCurrency(challenge.stakeAmount)}</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Potential yield:</span>
            <span className="font-medium text-green-600">+{challenge.yieldPercentage}%</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-500">Challenge type:</span>
            <span className={`font-medium ${challenge.isHardcore ? 'text-red-600' : 'text-blue-600'}`}>
              {challenge.isHardcore ? 'Hardcore' : 'No-Loss'}
            </span>
          </div>
        </div>
        
        {/* Action button */}
        {isActive ? (
          <Link 
            href={`/dashboard/challenges/${challenge.id}`}
            className="block w-full py-2 text-center bg-primary text-white rounded-md hover:bg-primary-dark transition-colors"
          >
            Continue Challenge
          </Link>
        ) : (
          <Link 
            href={`/dashboard/challenges/${challenge.id}`}
            className="block w-full py-2 text-center bg-primary text-white rounded-md hover:bg-primary-dark transition-colors"
          >
            View Challenge
          </Link>
        )}
      </div>
    </div>
  );
}

================
File: components/dashboard/LanguageStats.jsx
================
// components/dashboard/LanguageStats.jsx
import { useState, useEffect } from 'react';
import Link from 'next/link';

export default function LanguageStats({ languageCode, proficiencyLevel }) {
  const [stats, setStats] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  
  // Get language name from language code
  const getLanguageName = (code) => {
    const languages = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ru': 'Russian',
      'pt': 'Portuguese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    
    return languages[code] || code;
  };
  
  // Calculate progress percentage based on proficiency level
  const getProgressPercentage = (level) => {
    const levels = {
      'BEGINNER': 20,
      'ELEMENTARY': 40,
      'INTERMEDIATE': 60,
      'ADVANCED': 80,
      'FLUENT': 100
    };
    
    return levels[level] || 0;
  };
  
  useEffect(() => {
    // This would normally fetch real stats from an API
    // For now, we'll use dummy data
    const fetchStats = async () => {
      setIsLoading(true);
      try {
        // In a real app, you would fetch stats from the server
        // const response = await fetch(`/api/stats/language/${languageCode}`);
        // const data = await response.json();
        
        // Dummy data for now
        const dummyData = {
          streak: Math.floor(Math.random() * 30),
          vocabularySize: Math.floor(Math.random() * 2000) + 100,
          minutesPracticed: Math.floor(Math.random() * 500) + 50,
          lastPracticed: new Date(Date.now() - Math.floor(Math.random() * 7 * 24 * 60 * 60 * 1000)).toISOString(),
        };
        
        setTimeout(() => {
          setStats(dummyData);
          setIsLoading(false);
        }, 500);
      } catch (error) {
        console.error('Error fetching language stats:', error);
        setIsLoading(false);
      }
    };
    
    fetchStats();
  }, [languageCode]);
  
  // Format date as relative time (e.g., "2 days ago")
  const getRelativeTime = (dateString) => {
    if (!dateString) return 'Never';
    
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    
    if (diffDays === 0) return 'Today';
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays} days ago`;
    if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
    return `${Math.floor(diffDays / 30)} months ago`;
  };
  
  if (isLoading) {
    return (
      <div className="rounded-lg border border-gray-200 p-4 animate-pulse">
        <div className="h-4 bg-gray-200 rounded w-1/4 mb-4"></div>
        <div className="h-2 bg-gray-200 rounded mb-2.5"></div>
        <div className="h-2 bg-gray-200 rounded mb-2.5"></div>
        <div className="h-2 bg-gray-200 rounded"></div>
      </div>
    );
  }
  
  return (
    <div className="border border-gray-200 rounded-lg overflow-hidden">
      <div className="px-4 py-3 bg-gray-50 border-b border-gray-200 flex justify-between items-center">
        <h3 className="font-semibold">{getLanguageName(languageCode)}</h3>
        <span className="text-sm text-gray-500">
          {proficiencyLevel.charAt(0) + proficiencyLevel.slice(1).toLowerCase()}
        </span>
      </div>
      
      <div className="p-4">
        {/* Progress bar */}
        <div className="mb-4">
          <div className="flex justify-between text-sm text-gray-500 mb-1">
            <span>Progress</span>
            <span>{getProgressPercentage(proficiencyLevel)}%</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-2">
            <div 
              className="bg-primary h-2 rounded-full" 
              style={{ width: `${getProgressPercentage(proficiencyLevel)}%` }}
            ></div>
          </div>
        </div>
        
        {/* Stats grid */}
        <div className="grid grid-cols-2 gap-4 mb-4">
          <div>
            <div className="text-sm text-gray-500">Current streak</div>
            <div className="font-bold text-lg">{stats.streak} days</div>
          </div>
          <div>
            <div className="text-sm text-gray-500">Vocabulary size</div>
            <div className="font-bold text-lg">{stats.vocabularySize} words</div>
          </div>
          <div>
            <div className="text-sm text-gray-500">Total practice time</div>
            <div className="font-bold text-lg">{stats.minutesPracticed} min</div>
          </div>
          <div>
            <div className="text-sm text-gray-500">Last practiced</div>
            <div className="font-bold text-lg">{getRelativeTime(stats.lastPracticed)}</div>
          </div>
        </div>
        
        {/* Action buttons */}
        <div className="flex gap-2">
          <Link 
            href={`/dashboard/learn?language=${languageCode}`}
            className="flex-1 py-2 text-center bg-primary text-white rounded-md hover:bg-primary-dark transition-colors"
          >
            Practice Now
          </Link>
          <Link 
            href={`/dashboard/challenges?language=${languageCode}`}
            className="flex-1 py-2 text-center border border-primary text-primary rounded-md hover:bg-primary-50 transition-colors"
          >
            Find Challenges
          </Link>
        </div>
      </div>
    </div>
  );
}

================
File: components/dashboard/RecentActivity.jsx
================
// components/dashboard/RecentActivity.jsx
import { useState, useEffect } from 'react';

export default function RecentActivity() {
  const [activities, setActivities] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  
  useEffect(() => {
    // This would normally fetch real activities from an API
    // For now, we'll use dummy data
    const fetchActivities = async () => {
      setIsLoading(true);
      try {
        // In a real app, you would fetch activities from the server
        // const response = await fetch('/api/activities');
        // const data = await response.json();
        
        // Dummy data for now
        const dummyData = [
          {
            id: '1',
            type: 'practice',
            language: 'ja',
            details: 'Completed 15 minute conversation',
            timestamp: new Date(Date.now() - 2 * 60 * 60 * 1000).toISOString(),
          },
          {
            id: '2',
            type: 'challenge',
            language: 'ja',
            details: 'Joined "60-Day Japanese Immersion"',
            timestamp: new Date(Date.now() - 25 * 60 * 60 * 1000).toISOString(),
          },
          {
            id: '3',
            type: 'achievement',
            language: 'ja',
            details: 'Earned "5-Day Streak" badge',
            timestamp: new Date(Date.now() - 3 * 24 * 60 * 60 * 1000).toISOString(),
          },
          {
            id: '4',
            type: 'practice',
            language: 'es',
            details: 'Learned 20 new vocabulary words',
            timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000).toISOString(),
          },
        ];
        
        setTimeout(() => {
          setActivities(dummyData);
          setIsLoading(false);
        }, 500);
      } catch (error) {
        console.error('Error fetching activities:', error);
        setIsLoading(false);
      }
    };
    
    fetchActivities();
  }, []);
  
  // Get language name from language code
  const getLanguageName = (code) => {
    const languages = {
      'en': 'English',
      'es': 'Spanish',
      'fr': 'French',
      'de': 'German',
      'it': 'Italian',
      'ja': 'Japanese',
      'ko': 'Korean',
      'zh': 'Chinese',
      'ru': 'Russian',
      'pt': 'Portuguese',
      'ar': 'Arabic',
      'hi': 'Hindi'
    };
    
    return languages[code] || code;
  };
  
  // Format date as relative time (e.g., "2 hours ago")
  const getRelativeTime = (dateString) => {
    if (!dateString) return '';
    
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now - date;
    const diffMins = Math.floor(diffMs / (1000 * 60));
    
    if (diffMins < 60) return `${diffMins} min ago`;
    
    const diffHours = Math.floor(diffMins / 60);
    if (diffHours < 24) return `${diffHours} hours ago`;
    
    const diffDays = Math.floor(diffHours / 24);
    if (diffDays === 1) return 'Yesterday';
    if (diffDays < 7) return `${diffDays} days ago`;
    
    const diffWeeks = Math.floor(diffDays / 7);
    if (diffWeeks < 4) return `${diffWeeks} weeks ago`;
    
    const diffMonths = Math.floor(diffDays / 30);
    return `${diffMonths} months ago`;
  };
  
  // Get icon for activity type
  const getActivityIcon = (type) => {
    switch (type) {
      case 'practice':
        return (
          <div className="rounded-full bg-blue-100 p-2">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-blue-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7h12m0 0l-4-4m4 4l-4 4m0 6H4m0 0l4 4m-4-4l4-4" />
            </svg>
          </div>
        );
      case 'challenge':
        return (
          <div className="rounded-full bg-purple-100 p-2">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-purple-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10" />
            </svg>
          </div>
        );
      case 'achievement':
        return (
          <div className="rounded-full bg-yellow-100 p-2">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-yellow-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
            </svg>
          </div>
        );
      default:
        return (
          <div className="rounded-full bg-gray-100 p-2">
            <svg xmlns="http://www.w3.org/2000/svg" className="h-4 w-4 text-gray-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
        );
    }
  };
if (isLoading) {
    return (
      <div className="space-y-4">
        {[1, 2, 3].map((item) => (
          <div key={item} className="flex items-start space-x-3 animate-pulse">
            <div className="rounded-full bg-gray-200 h-8 w-8"></div>
            <div className="flex-1">
              <div className="h-4 bg-gray-200 rounded w-3/4 mb-2"></div>
              <div className="h-3 bg-gray-200 rounded w-1/2"></div>
            </div>
          </div>
        ))}
      </div>
    );
  }
  
  if (activities.length === 0) {
    return (
      <div className="text-center py-8">
        <p className="text-gray-500">No recent activity.</p>
        <p className="text-sm text-gray-400 mt-1">Start learning to see your activities here.</p>
      </div>
    );
  }
  
  return (
    <div className="space-y-4">
      {activities.map((activity) => (
        <div key={activity.id} className="flex items-start space-x-3">
          {getActivityIcon(activity.type)}
          <div className="flex-1">
            <div className="flex justify-between">
              <span className="text-sm font-medium">
                {getLanguageName(activity.language)}
              </span>
              <span className="text-xs text-gray-500">
                {getRelativeTime(activity.timestamp)}
              </span>
            </div>
            <p className="text-sm text-gray-600">{activity.details}</p>
          </div>
        </div>
      ))}
    </div>
  );
}

================
File: components/layout/DashboardLayout.jsx
================
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import Image from 'next/image';
import { usePathname, useRouter } from 'next/navigation';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';

export default function DashboardLayout({ children }) {
  const pathname = usePathname();
  const router = useRouter();
  const [user, setUser] = useState(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);
  const [isMobileSidebarOpen, setIsMobileSidebarOpen] = useState(false);
  const [notifications, setNotifications] = useState([]);
  const [hasUnreadNotifications, setHasUnreadNotifications] = useState(false);
  
  useEffect(() => {
    async function fetchUserData() {
      try {
        setIsLoading(true);
        const res = await fetch('/api/users/profile');
        
        if (!res.ok) {
          if (res.status === 401) {
            router.push('/auth/signin');
            return;
          }
          throw new Error('Failed to fetch user data');
        }
        
        const userData = await res.json();
        setUser(userData);
        
        // Fetch notifications
        try {
          const notificationsRes = await fetch('/api/notifications');
          if (notificationsRes.ok) {
            const notificationsData = await notificationsRes.json();
            setNotifications(notificationsData);
            setHasUnreadNotifications(notificationsData.some(notification => !notification.read));
          }
        } catch (notificationError) {
          console.error('Error fetching notifications:', notificationError);
        }
      } catch (error) {
        console.error('Error loading user profile:', error);
      } finally {
        setIsLoading(false);
      }
    }
    
    fetchUserData();
  }, [router]);
  
  // Close mobile menu/sidebar when route changes
  useEffect(() => {
    setIsMobileMenuOpen(false);
    setIsMobileSidebarOpen(false);
  }, [pathname]);
  
  const handleLogout = async () => {
    try {
      await fetch('/api/auth/logout', {
        method: 'POST',
      });
      
      router.push('/');
    } catch (error) {
      console.error('Error during logout:', error);
    }
  };
  
  const navItems = [
    { 
      path: '/dashboard', 
      label: 'Dashboard', 
      icon: 'M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6' 
    },
    { 
      path: '/dashboard/learn', 
      label: 'Learn', 
      icon: 'M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253' 
    },
    { 
      path: '/dashboard/challenges', 
      label: 'Challenges', 
      icon: 'M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10' 
    },
    { 
      path: '/dashboard/statistics', 
      label: 'Statistics', 
      icon: 'M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z'
    },
    { 
      path: '/dashboard/profile', 
      label: 'Profile', 
      icon: 'M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z' 
    },
  ];
  
  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-gray-50">
        <div className="text-center">
          <LoadingSpinner size="large" />
          <p className="mt-4 text-gray-500">Loading dashboard...</p>
        </div>
      </div>
    );
  }
  
  return (
    <div className="min-h-screen bg-gray-50">
      {/* Top navigation */}
      <nav className="bg-white shadow-sm border-b fixed top-0 left-0 right-0 z-30">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16">
            <div className="flex items-center">
              {/* Mobile menu button */}
              <button
                type="button"
                className="inline-flex items-center justify-center rounded-md p-2 text-gray-400 md:hidden"
                onClick={() => setIsMobileSidebarOpen(true)}
              >
                <span className="sr-only">Open sidebar</span>
                <svg
                  className="h-6 w-6"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                  aria-hidden="true"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth="2"
                    d="M4 6h16M4 12h16M4 18h16"
                  />
                </svg>
              </button>
              
              <div className="flex-shrink-0 flex items-center ml-0 md:ml-0">
                <Link href="/dashboard" className="flex items-center">
                  <div className="w-10 h-10 relative">
                    <div className="relative bg-gradient-to-br from-cyan-400 to-teal-500 rounded-xl w-full h-full flex items-center justify-center overflow-hidden border-2 border-cyan-300 shadow-md">
                      {/* Eyes */}
                      <div className="flex space-x-1">
                        <div className="bg-yellow-300 rounded-full w-[20%] h-[20%] flex items-center justify-center border border-yellow-400">
                          <div className="bg-black rounded-full w-[50%] h-[50%]"></div>
                        </div>
                        <div className="bg-yellow-300 rounded-full w-[20%] h-[20%] flex items-center justify-center border border-yellow-400">
                          <div className="bg-black rounded-full w-[50%] h-[50%]"></div>
                        </div>
                      </div>
                      
                      {/* Antenna */}
                      <div className="absolute -top-1 left-1/2 transform -translate-x-1/2">
                        <div className="w-[2px] h-[5px] bg-slate-600"></div>
                        <div className="w-[4px] h-[4px] rounded-full bg-red-500 animate-pulse"></div>
                      </div>
                      
                      {/* Mouth */}
                      <div className="absolute bottom-[15%] w-[40%] h-[2px] bg-slate-700 rounded-full"></div>
                    </div>
                  </div>
                  <span className="ml-2 font-bold text-xl hidden sm:block">ShinobiSpeak</span>
                </Link>
              </div>
            </div>
            
            <div className="flex items-center">
              {/* Create Challenge Button for Desktop */}
              <Link 
                href="/dashboard/challenges/create"
                className="hidden md:flex items-center mr-4 px-4 py-2 text-sm font-medium rounded-md bg-gradient-to-r from-cyan-500 to-teal-500 text-white shadow-sm hover:from-cyan-600 hover:to-teal-600"
              >
                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor">
                  <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
                </svg>
                New Challenge
              </Link>
              
              {/* Notifications button */}
              <button className="p-2 rounded-full text-gray-400 hover:text-gray-500 relative">
                <span className="sr-only">View notifications</span>
                <svg className="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
                </svg>
                {hasUnreadNotifications && (
                  <span className="absolute top-1 right-1 block h-2 w-2 rounded-full bg-red-400 ring-2 ring-white"></span>
                )}
              </button>
              
              {/* Profile dropdown */}
              <div className="ml-3 relative">
                <div className="flex items-center">
                  <button
                    type="button"
                    className="flex rounded-full bg-white text-sm focus:outline-none focus:ring-2 focus:ring-cyan-500 focus:ring-offset-2"
                    id="user-menu-button"
                    onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
                  >
                    <span className="sr-only">Open user menu</span>
                    <div className="h-8 w-8 rounded-full bg-gray-200 flex items-center justify-center text-gray-600 font-medium">
                      {user?.username?.charAt(0) || user?.walletAddress?.slice(0, 2) || "U"}
                    </div>
                  </button>
                  <span className="hidden md:block ml-3 text-sm font-medium text-gray-700">
                    {user?.username || 'Loading...'}
                  </span>
                </div>
                
                {/* Mobile menu dropdown */}
                <div
                  className={`${
                    isMobileMenuOpen ? 'absolute' : 'hidden'
                  } right-0 z-10 mt-2 w-48 origin-top-right rounded-md bg-white py-1 shadow-lg ring-1 ring-black ring-opacity-5 focus:outline-none`}
                  role="menu"
                  aria-orientation="vertical"
                  aria-labelledby="user-menu-button"
                  tabIndex="-1"
                >
                  <div className="block px-4 py-2 text-xs text-gray-400">Manage Account</div>
                  <Link
                    href="/dashboard/profile"
                    className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                    role="menuitem"
                  >
                    Your Profile
                  </Link>
                  <button
                    onClick={handleLogout}
                    className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                    role="menuitem"
                  >
                    Sign out
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </nav>
      
      {/* Mobile sidebar backdrop */}
      {isMobileSidebarOpen && (
        <div 
          className="fixed inset-0 z-40 bg-gray-600 bg-opacity-75 md:hidden"
          onClick={() => setIsMobileSidebarOpen(false)}
        ></div>
      )}
      
      {/* Mobile sidebar */}
      <div 
        className={`fixed inset-y-0 left-0 z-50 w-full max-w-xs bg-white transform transition-transform ease-in-out duration-300 md:hidden ${
          isMobileSidebarOpen ? 'translate-x-0' : '-translate-x-full'
        }`}
      >
        <div className="flex items-center justify-between h-16 px-4 border-b border-gray-200">
          <div className="flex items-center">
            <div className="flex-shrink-0">
              <div className="w-10 h-10 relative">
                <div className="relative bg-gradient-to-br from-cyan-400 to-teal-500 rounded-xl w-full h-full flex items-center justify-center overflow-hidden border-2 border-cyan-300 shadow-md">
                  {/* Robot elements */}
                  <div className="flex space-x-1">
                    <div className="bg-yellow-300 rounded-full w-[20%] h-[20%]"></div>
                    <div className="bg-yellow-300 rounded-full w-[20%] h-[20%]"></div>
                  </div>
                </div>
              </div>
            </div>
            <div className="ml-2 font-bold text-xl">ShinobiSpeak</div>
          </div>
          <button 
            className="rounded-md p-2 text-gray-400 hover:text-gray-500 focus:outline-none"
            onClick={() => setIsMobileSidebarOpen(false)}
          >
            <span className="sr-only">Close sidebar</span>
            <svg className="h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M6 18L18 6M6 6l12 12" />
            </svg>
          </button>
        </div>
        
        <div className="mt-4 px-2 space-y-1">
          {/* Create Challenge Button for Mobile Sidebar */}
          <Link
            href="/dashboard/challenges/create"
            className="group flex items-center px-2 py-2 text-base font-medium rounded-md bg-gradient-to-r from-cyan-500 to-teal-500 text-white"
          >
            <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 mr-3 text-white" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
            </svg>
            New Challenge
          </Link>
          
          {navItems.map((item) => (
            <Link
              key={item.path}
              href={item.path}
              className={`${
                pathname === item.path
                  ? 'bg-cyan-50 text-cyan-600 border-l-4 border-cyan-500'
                  : 'text-gray-700 hover:bg-gray-100 border-l-4 border-transparent'
              } group flex items-center px-2 py-2 text-base font-medium rounded-md`}
            >
              <svg
                className={`${
                  pathname === item.path ? 'text-cyan-500' : 'text-gray-500'
                } mr-3 h-6 w-6`}
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d={item.icon}
                />
              </svg>
              {item.label}
            </Link>
          ))}
          
          <div className="pt-4 mt-4 border-t border-gray-200">
            <button
              onClick={handleLogout}
              className="group flex items-center px-2 py-2 text-base font-medium text-gray-700 hover:bg-gray-100 rounded-md w-full"
            >
              <svg className="mr-3 h-6 w-6 text-gray-500" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
              </svg>
              Sign out
            </button>
          </div>
        </div>
      </div>
      
      {/* Content area with sidebar */}
      <div className="flex flex-col md:flex-row pt-16">
        {/* Sidebar for desktop */}
        <div className="hidden md:flex md:flex-col md:w-64 md:fixed md:inset-y-0 md:pt-16 bg-white shadow-sm border-r border-gray-200 overflow-y-auto">
          <div className="flex-1 flex flex-col pt-5 pb-4">
            <nav className="mt-1 flex-1 px-2 space-y-1">
              {navItems.map((item) => (
                <Link
                  key={item.path}
                  href={item.path}
                  className={`${
                    pathname === item.path
                      ? 'bg-cyan-50 text-cyan-600 border-l-4 border-cyan-500'
                      : 'text-gray-700 hover:bg-gray-100 border-l-4 border-transparent'
                  } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
                >
                  <svg
                    className={`${
                      pathname === item.path ? 'text-cyan-500' : 'text-gray-500 group-hover:text-gray-600'
                    } mr-3 h-5 w-5`}
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    stroke="currentColor"
                  >
                    <path
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      strokeWidth="2"
                      d={item.icon}
                    />
                  </svg>
                  {item.label}
                </Link>
              ))}
            </nav>
          </div>
          
          {/* User info in sidebar */}
          <div className="flex-shrink-0 flex border-t border-gray-200 p-4">
            <div className="flex-shrink-0 w-full group block">
              <div className="flex items-center">
                <div className="h-8 w-8 rounded-full bg-gray-200 flex items-center justify-center text-gray-600 font-medium">
                  {user?.username?.charAt(0) || user?.walletAddress?.slice(0, 2) || "U"}
                </div>
                <div className="ml-3">
                  <p className="text-sm font-medium text-gray-700 truncate">{user?.username}</p>
                  <p className="text-xs font-medium text-gray-500 truncate">
                    {user?.walletAddress?.slice(0, 6)}...{user?.walletAddress?.slice(-4)}
                  </p>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        {/* Main content */}
        <main className="flex-1 md:pl-64">
          <div className="py-6">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 md:px-8">
              {children}
            </div>
          </div>
        </main>
      </div>
      
      {/* Mobile bottom navigation */}
      <div className="fixed bottom-0 left-0 right-0 z-20 bg-white shadow-t border-t border-gray-200 md:hidden">
        <div className="flex justify-around">
          {navItems.map((item) => (
            <Link
              key={item.path}
              href={item.path}
              className={`flex flex-col items-center py-2 px-3 ${
                pathname === item.path ? 'text-cyan-600' : 'text-gray-500'
              }`}
            >
              <svg
                className="h-6 w-6"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
                stroke="currentColor"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d={item.icon}
                />
              </svg>
              <span className="text-xs mt-1">{item.label}</span>
            </Link>
          ))}
        </div>
      </div>
      
      {/* Floating action button for mobile - Create Challenge */}
      <div className="fixed bottom-20 right-4 md:hidden z-30">
        <Link
          href="/dashboard/challenges/create"
          className="flex items-center justify-center w-14 h-14 rounded-full bg-gradient-to-r from-cyan-500 to-teal-500 text-white shadow-lg hover:from-cyan-600 hover:to-teal-600"
        >
          <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
            <path fillRule="evenodd" d="M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z" clipRule="evenodd" />
          </svg>
        </Link>
      </div>
    </div>
  );
}

================
File: components/learn/ConversationInterface.jsx
================
'use client';

import { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { LoadingSpinner } from '@/components/ui/LoadingSpinner';

export default function ConversationInterface({ languageCode, userChallengeId }) {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const [isLoading, setIsLoading] = useState(false);
  const [conversationId, setConversationId] = useState(null);
  const [practiceTime, setPracticeTime] = useState(0);
  const [practiceStatus, setPracticeStatus] = useState({
    isActive: true,
    dailyGoal: 0,
    progress: 0,
    isCompleted: false
  });
  const [sessionStartTime, setSessionStartTime] = useState(null);
  const messagesEndRef = useRef(null);
  const router = useRouter();
  
  // Initialize practice session and fetch daily goal
  useEffect(() => {
    const fetchPracticeInfo = async () => {
      if (!userChallengeId) return;
      
      try {
        const response = await fetch(`/api/challenges/practice-info?userChallengeId=${userChallengeId}`);
        if (response.ok) {
          const data = await response.json();
          setPracticeStatus({
            isActive: true,
            dailyGoal: data.dailyRequirement || 20,
            progress: data.todayProgress || 0,
            isCompleted: data.todayCompleted || false
          });
        }
      } catch (error) {
        console.error('Error fetching practice info:', error);
      }
    };
    
    fetchPracticeInfo();
    setSessionStartTime(new Date());
  }, [userChallengeId]);
  
  // Timer for practice tracking - update every minute
  useEffect(() => {
    let timer;
    if (sessionStartTime) {
      // Initial calculation
      const calculatePracticeTime = () => {
        const now = new Date();
        const elapsedMinutes = Math.floor((now - sessionStartTime) / 60000);
        setPracticeTime(elapsedMinutes);
        
        // Update progress if part of a challenge
        if (userChallengeId) {
          setPracticeStatus(prev => ({
            ...prev,
            progress: prev.progress + 1,
            isCompleted: prev.progress + 1 >= prev.dailyGoal
          }));
          
          // Send progress update to server
          updatePracticeProgress(elapsedMinutes);
        }
      };
      
      // Set timer to run every minute
      timer = setInterval(calculatePracticeTime, 60000);
    }
    
    return () => clearInterval(timer);
  }, [sessionStartTime, userChallengeId]);
  
  // Function to update practice progress on server
  const updatePracticeProgress = async (minutes) => {
    if (!userChallengeId) return;
    
    try {
      await fetch('/api/challenges/update-progress', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          userChallengeId,
          minutes: 1 // We track 1 minute at a time
        }),
      });
    } catch (error) {
      console.error('Error updating practice progress:', error);
    }
  };
  
  // Start conversation with initial greeting
  useEffect(() => {
    const startConversation = async () => {
      setIsLoading(true);
      try {
        const response = await fetch('/api/conversation', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            message: 'Hello, I would like to practice conversation.',
            languageCode,
            userChallengeId
          }),
        });
        
        if (!response.ok) {
          throw new Error('Failed to start conversation');
        }
        
        const data = await response.json();
        
        setMessages([
          { sender: 'user', content: 'Hello, I would like to practice conversation.' },
          { sender: 'ai', content: data.content }
        ]);
        setConversationId(data.conversationId);
      } catch (error) {
        console.error('Error starting conversation:', error);
        setMessages([
          { 
            sender: 'system', 
            content: 'There was an error starting the conversation. Please try again or contact support.' 
          }
        ]);
      } finally {
        setIsLoading(false);
      }
    };
    
    if (languageCode && messages.length === 0) {
      startConversation();
    }
  }, [languageCode, userChallengeId]);
  
  
  // Scroll to bottom of messages
  useEffect(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  }, [messages]);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    
    if (!input.trim() || isLoading) return;
    
    const userMessage = input.trim();
    setInput('');
    setIsLoading(true);
    
    // Add user message immediately
    setMessages(prev => [...prev, { sender: 'user', content: userMessage }]);
    
    try {
      const response = await fetch('/api/conversation', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: userMessage,
          conversationId,
          languageCode,
          userChallengeId
        }),
      });
      
      if (!response.ok) {
        throw new Error('Failed to send message');
      }
      
      const data = await response.json();
      
      // Add AI response
      setMessages(prev => [...prev, { sender: 'ai', content: data.content }]);
      
      // Update conversation ID if it's a new conversation
      if (!conversationId && data.conversationId) {
        setConversationId(data.conversationId);
      }
    } catch (error) {
      console.error('Error sending message:', error);
      setMessages(prev => [...prev, { 
        sender: 'system', 
        content: 'Sorry, there was an error processing your message. Please try again.' 
      }]);
    } finally {
      setIsLoading(false);
    }
  };
  
  const handleEndSession = async () => {
    try {
      // Calculate final practice time
      const finalMinutes = practiceTime;
      
      // Ensure we save the final practice minutes
      if (userChallengeId && finalMinutes > 0) {
        await fetch('/api/challenges/update-progress', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            userChallengeId,
            minutes: finalMinutes,
            isSessionEnd: true,
            conversationId
          }),
        });
      }
      
      // Optionally get a summary of the session
      if (conversationId) {
        await fetch('/api/conversation/evaluate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            conversationId
          }),
        });
      }
      
      router.push('/dashboard');
    } catch (error) {
      console.error('Error ending session:', error);
      router.push('/dashboard');
    }
  };


  const renderProgressBar = () => {
    if (!userChallengeId) return null;
    
    const percentage = Math.min(100, (practiceStatus.progress / practiceStatus.dailyGoal) * 100);
    
    return (
      <div className="mb-4">
        <div className="flex justify-between text-sm text-slate-500 mb-1">
          <span>Daily Goal: {practiceStatus.progress}/{practiceStatus.dailyGoal} minutes</span>
          <span>{percentage.toFixed(0)}%</span>
        </div>
        <div className="w-full bg-slate-200 rounded-full h-2">
          <div 
            className={`h-2 rounded-full ${
              practiceStatus.isCompleted 
                ? 'bg-green-500' 
                : 'bg-gradient-to-r from-cyan-400 to-teal-500'
            }`}
            style={{ width: `${percentage}%` }}
          ></div>
        </div>
        {practiceStatus.isCompleted && (
          <p className="text-sm text-green-600 mt-1">
             Daily goal completed! Keep practicing for extra progress.
          </p>
        )}
      </div>
    );
  };
  
  
  return (
    <div className="flex flex-col h-full max-h-screen bg-slate-50">
      {/* Header */}
      <div className="bg-white border-b border-slate-200 p-4">
        <div className="flex items-center justify-between">
          <div className="flex items-center">
            <div className="mr-3">
              <div className="w-10 h-10 bg-gradient-to-br from-cyan-400 to-teal-500 rounded-full flex items-center justify-center">
                {languageCode === 'ja' ? '' : 
                 languageCode === 'ko' ? '' : 
                 languageCode === 'zh' ? '' : 
                 languageCode === 'en' ? '' : 
                 languageCode === 'es' ? '' : 
                 languageCode === 'fr' ? '' : ''}
              </div>
            </div>
            <div>
              <h2 className="font-bold text-slate-800">
                {languageCode === 'ja' ? 'Japanese' : 
                 languageCode === 'ko' ? 'Korean' : 
                 languageCode === 'zh' ? 'Chinese' : 
                 languageCode === 'en' ? 'English' : 
                 languageCode === 'es' ? 'Spanish' : 
                 languageCode === 'fr' ? 'French' : 'Conversation'} Practice
              </h2>
              <p className="text-sm text-slate-500">Practice time: {practiceTime} minutes</p>
            </div>
          </div>
          <button 
            onClick={handleEndSession}
            className="px-4 py-2 bg-slate-100 hover:bg-slate-200 text-slate-700 rounded-lg"
          >
            End Session
          </button>
        </div>
        {renderProgressBar()}
      </div>
      
      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {messages.map((message, index) => (
          <div key={index} className={`flex ${message.sender === 'user' ? 'justify-end' : 'justify-start'}`}>
            <div className={`max-w-[75%] rounded-lg p-4 ${
              message.sender === 'user' 
                ? 'bg-cyan-100 text-slate-800' 
                : message.sender === 'ai'
                ? 'bg-white border border-slate-200 text-slate-800'
                : 'bg-red-100 text-red-800'
            }`}>
              {message.content}
            </div>
          </div>
        ))}
        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-white border border-slate-200 rounded-lg p-4 max-w-[75%]">
              <div className="flex space-x-2">
                <div className="w-3 h-3 bg-slate-300 rounded-full animate-bounce"></div>
                <div className="w-3 h-3 bg-slate-300 rounded-full animate-bounce" style={{ animationDelay: '0.2s' }}></div>
                <div className="w-3 h-3 bg-slate-300 rounded-full animate-bounce" style={{ animationDelay: '0.4s' }}></div>
              </div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
      </div>
      
      {/* Input */}
      <div className="border-t border-slate-200 p-4 bg-white">
        <form onSubmit={handleSubmit} className="flex space-x-2">
          <input
            type="text"
            value={input}
            onChange={(e) => setInput(e.target.value)}
            disabled={isLoading}
            placeholder="Type your message..."
            className="flex-1 px-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-cyan-500"
          />
          <button
            type="submit"
            disabled={isLoading}
            className="px-4 py-2 bg-gradient-to-r from-cyan-500 to-teal-500 text-white rounded-lg hover:from-cyan-600 hover:to-teal-600 disabled:opacity-50"
          >
            Send
          </button>
        </form>
      </div>
      
    </div>
  );
}

================
File: components/ui/button.jsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props} />
  );
}

export { Button, buttonVariants }

================
File: components/ui/EmptyState.jsx
================
// components/ui/EmptyState.jsx
  export default function EmptyState({
    title = 'No data found',
    message = 'There are no items to display at this time.',
    icon = null,
    action = null
  }) {
    return (
      <div className="text-center p-8 border border-gray-200 rounded-lg bg-white">
        {icon || (
          <svg
            className="mx-auto h-12 w-12 text-gray-400"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            aria-hidden="true"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={1.5}
              d="M20 13V6a2 2 0 00-2-2H6a2 2 0 00-2 2v7m16 0v5a2 2 0 01-2 2H6a2 2 0 01-2-2v-5m16 0h-2.586a1 1 0 00-.707.293l-2.414 2.414a1 1 0 01-.707.293h-3.172a1 1 0 01-.707-.293l-2.414-2.414A1 1 0 006.586 13H4"
            />
          </svg>
        )}
        <h3 className="mt-2 text-sm font-medium text-gray-900">{title}</h3>
        <p className="mt-1 text-sm text-gray-500">{message}</p>
        {action && (
          <div className="mt-6">
            <button
              type="button"
              className="inline-flex items-center rounded-md bg-primary px-3 py-2 text-sm font-semibold text-white shadow-sm hover:bg-primary-dark focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-primary"
              onClick={action.onClick}
            >
              {action.icon && (
                <span className="mr-2">{action.icon}</span>
              )}
              {action.text}
            </button>
          </div>
        )}
      </div>
    );
  }

================
File: components/ui/ErrorMessage.jsx
================
// components/ui/ErrorMessage.jsx
export default function ErrorMessage({ 
    message, 
    title = "Error", 
    retry = null,
    dismiss = null,
    variant = "error" // 'error', 'warning', 'info' 
  }) {
    const getColorClasses = () => {
      switch (variant) {
        case 'warning':
          return 'bg-amber-50 border-amber-200 text-amber-800';
        case 'info':
          return 'bg-blue-50 border-blue-200 text-blue-800';
        case 'error':
        default:
          return 'bg-red-50 border-red-200 text-red-800';
      }
    };
  
    const getIcon = () => {
      switch (variant) {
        case 'warning':
          return (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-amber-500" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
          );
        case 'info':
          return (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-blue-500" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a1 1 0 000 2v3a1 1 0 001 1h1a1 1 0 100-2v-3a1 1 0 00-1-1H9z" clipRule="evenodd" />
            </svg>
          );
        case 'error':
        default:
          return (
            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 text-red-500" viewBox="0 0 20 20" fill="currentColor">
              <path fillRule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
            </svg>
          );
      }
    };
  
    return (
      <div className={`rounded-md border p-4 ${getColorClasses()}`}>
        <div className="flex">
          <div className="flex-shrink-0">
            {getIcon()}
          </div>
          <div className="ml-3 flex-1">
            <h3 className="text-sm font-medium">{title}</h3>
            <div className="mt-2 text-sm">
              <p>{message}</p>
            </div>
            {(retry || dismiss) && (
              <div className="mt-4">
                <div className="-mx-2 -my-1.5 flex">
                  {retry && (
                    <button
                      type="button"
                      onClick={retry}
                      className={`rounded-md px-2 py-1.5 text-sm font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 ${
                        variant === 'error' 
                          ? 'bg-red-100 text-red-800 hover:bg-red-200 focus:ring-red-600' 
                          : variant === 'warning'
                          ? 'bg-amber-100 text-amber-800 hover:bg-amber-200 focus:ring-amber-600'
                          : 'bg-blue-100 text-blue-800 hover:bg-blue-200 focus:ring-blue-600'
                      }`}
                    >
                      Try again
                    </button>
                  )}
                  {dismiss && (
                    <button
                      type="button"
                      onClick={dismiss}
                      className="ml-3 rounded-md bg-white px-2 py-1.5 text-sm font-medium text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-500"
                    >
                      Dismiss
                    </button>
                  )}
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  }

================
File: components/ui/LoadingSpinner.jsx
================
// components/ui/LoadingSpinner.jsx
  export function LoadingSpinner({ size = 'medium', color = 'primary', fullPage = false }) {
    const sizeClasses = {
      small: 'h-4 w-4',
      medium: 'h-8 w-8',
      large: 'h-12 w-12'
    };
    
    const colorClasses = {
      primary: 'text-primary',
      white: 'text-white',
      gray: 'text-gray-500'
    };
    
    if (fullPage) {
      return (
        <div className="fixed inset-0 bg-gray-800 bg-opacity-75 flex items-center justify-center z-50">
          <div className="bg-white p-6 rounded-lg shadow-xl flex flex-col items-center">
            <svg 
              className={`animate-spin ${sizeClasses[size]} ${colorClasses.primary}`} 
              xmlns="http://www.w3.org/2000/svg" 
              fill="none" 
              viewBox="0 0 24 24"
            >
              <circle 
                className="opacity-25" 
                cx="12" 
                cy="12" 
                r="10" 
                stroke="currentColor" 
                strokeWidth="4"
              ></circle>
              <path 
                className="opacity-75" 
                fill="currentColor" 
                d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
              ></path>
            </svg>
            <p className="mt-2 text-sm text-gray-700">Loading...</p>
          </div>
        </div>
      );
    }
    
    return (
      <svg 
        className={`animate-spin ${sizeClasses[size]} ${colorClasses[color]}`} 
        xmlns="http://www.w3.org/2000/svg" 
        fill="none" 
        viewBox="0 0 24 24"
      >
        <circle 
          className="opacity-25" 
          cx="12" 
          cy="12" 
          r="10" 
          stroke="currentColor" 
          strokeWidth="4"
        ></circle>
        <path 
          className="opacity-75" 
          fill="currentColor" 
          d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
        ></path>
      </svg>
    );
  }

================
File: components/ui/LoadingState.jsx
================
// components/ui/LoadingState.jsx
  import { LoadingSpinner } from './LoadingSpinner';
  
  export default function LoadingState({ 
    message = 'Loading...', 
    size = 'medium',
    height = 'auto'
  }) {
    const heightClass = height === 'auto' ? 'min-h-[100px]' : `h-${height}`;
  
    return (
      <div className={`flex flex-col items-center justify-center ${heightClass} w-full`}>
        <LoadingSpinner size={size} />
        <p className="mt-2 text-sm text-gray-500">{message}</p>
      </div>
    );
  }

================
File: components/ui/TransactionStatus.jsx
================
// components/ui/TransactionStatus.jsx
  import { useState, useEffect } from 'react';
  
  export default function TransactionStatus({ 
    txHash, 
    status, 
    network = 'polygon', 
    message,
    onClose
  }) {
    const [explorerLink, setExplorerLink] = useState('');
    
    useEffect(() => {
      if (txHash) {
        // Set the appropriate block explorer URL based on network
        const baseUrl = 
          network === 'ethereum' ? 'https://etherscan.io/tx/' :
          network === 'polygon' ? 'https://polygonscan.com/tx/' :
          network === 'mumbai' ? 'https://mumbai.polygonscan.com/tx/' :
          'https://polygonscan.com/tx/'; // Default to polygon
        
        setExplorerLink(`${baseUrl}${txHash}`);
      }
    }, [txHash, network]);
    
    const statusColor = 
      status === 'success' ? 'text-green-600 bg-green-50 border-green-200' :
      status === 'pending' ? 'text-yellow-600 bg-yellow-50 border-yellow-200' :
      'text-red-600 bg-red-50 border-red-200';
    
    const statusIcon = 
      status === 'success' ? (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
        </svg>
      ) : status === 'pending' ? (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-yellow-500 animate-pulse" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
        </svg>
      ) : (
        <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6 text-red-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
        </svg>
      );
    
    return (
      <div className={`rounded-md border p-4 ${statusColor}`}>
        <div className="flex">
          <div className="flex-shrink-0">
            {statusIcon}
          </div>
          <div className="ml-3 flex-1">
            <h3 className="text-md font-medium">
              {status === 'success' ? 'Transaction Successful' :
               status === 'pending' ? 'Transaction Pending' :
               'Transaction Failed'}
            </h3>
            {message && <p className="mt-1 text-sm">{message}</p>}
            {txHash && (
              <div className="mt-2">
                <a 
                  href={explorerLink} 
                  target="_blank" 
                  rel="noopener noreferrer" 
                  className="text-sm font-medium underline"
                >
                  View on Block Explorer
                </a>
              </div>
            )}
          </div>
          {onClose && (
            <button 
              type="button" 
              className="ml-auto -mx-1.5 -my-1.5 bg-white text-gray-400 hover:text-gray-500 rounded-lg focus:ring-2 focus:ring-gray-300 p-1.5 inline-flex h-8 w-8" 
              onClick={onClose}
            >
              <span className="sr-only">Close</span>
              <svg className="w-5 h-5" fill="currentColor" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path fillRule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clipRule="evenodd"></path>
              </svg>
            </button>
          )}
        </div>
      </div>
    );
  }

================
File: contracts/StakingChallenge.sol
================
// contracts/StakingChallenge.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract StakingChallenge is Ownable, ReentrancyGuard {
    IERC20 public usdcToken;
    
    struct Challenge {
        string id;
        uint256 stakeAmount;
        uint256 yieldBps; // Basis points (1/100 of a percent)
        bool isHardcore;
        uint256 durationDays;
        bool isActive;
        address creator;
        uint256 createdAt;
    }
    
    struct Stake {
        string challengeId;
        uint256 amount;
        uint256 timestamp;
        bool isHardcore;
        bool isCompleted;
        bool isFailed;
    }
    
    mapping(string => Challenge) public challenges;
    mapping(address => mapping(string => Stake)) public stakes;
    mapping(address => string[]) public userActiveChallenges;
    
    uint256 public totalStaked;
    uint256 public totalYieldGenerated;
    uint256 public totalChallenges;
    
    // Events
    event ChallengeRegistered(string challengeId, address indexed creator, uint256 stakeAmount, uint256 yieldBps, bool isHardcore);
    event StakeReceived(address indexed staker, string challengeId, uint256 amount, bool isHardcore);
    event ChallengeCompleted(address indexed staker, string challengeId, uint256 reward);
    event ChallengeFailed(address indexed staker, string challengeId);
    
    constructor(address _usdcToken) {
        usdcToken = IERC20(_usdcToken);
    }
    
    /**
     * @dev Registers a new language learning challenge
     * @param challengeId The unique identifier of the challenge
     * @param stakeAmount The amount required to stake (in USDC cents)
     * @param yieldBps The yield percentage in basis points (e.g., 500 = 5%)
     * @param isHardcore Whether the challenge is hardcore (stake can be lost) or not
     * @param durationDays The duration of the challenge in days
     */
    function registerChallenge(
        string memory challengeId,
        uint256 stakeAmount,
        uint256 yieldBps,
        bool isHardcore,
        uint256 durationDays
    ) external nonReentrant {
        require(bytes(challengeId).length > 0, "Challenge ID cannot be empty");
        require(stakeAmount > 0, "Stake amount must be greater than 0");
        require(durationDays > 0, "Duration must be greater than 0");
        require(yieldBps <= 2000, "Yield cannot exceed 20%"); // Max 20% yield
        
        // Check if challenge already exists
        require(challenges[challengeId].createdAt == 0, "Challenge ID already exists");
        
        // Register the challenge
        challenges[challengeId] = Challenge({
            id: challengeId,
            stakeAmount: stakeAmount,
            yieldBps: yieldBps,
            isHardcore: isHardcore,
            durationDays: durationDays,
            isActive: true,
            creator: msg.sender,
            createdAt: block.timestamp
        });
        
        totalChallenges++;
        
        emit ChallengeRegistered(challengeId, msg.sender, stakeAmount, yieldBps, isHardcore);
    }
    
    /**
     * @dev Allows a user to stake USDC for a language learning challenge
     * @param challengeId The unique identifier of the challenge
     * @param amount The amount of USDC to stake
     * @param isHardcore Whether the challenge is hardcore (stake can be lost) or not
     */
    function stakeForChallenge(string memory challengeId, uint256 amount, bool isHardcore) external nonReentrant {
        require(amount > 0, "Stake amount must be greater than 0");
        require(stakes[msg.sender][challengeId].amount == 0, "Already staked for this challenge");
        
        // Verify challenge exists
        Challenge memory challenge = challenges[challengeId];
        require(challenge.createdAt > 0, "Challenge does not exist");
        require(challenge.isActive, "Challenge is not active");
        
        // Verify stake amount matches challenge requirement if challenge is registered
        if (challenge.stakeAmount > 0) {
            require(amount == challenge.stakeAmount, "Stake amount must match challenge requirement");
            require(isHardcore == challenge.isHardcore, "Hardcore flag must match challenge setting");
        }
        
        // Transfer USDC from user to contract
        require(usdcToken.transferFrom(msg.sender, address(this), amount), "USDC transfer failed");
        
        // Create stake record
        stakes[msg.sender][challengeId] = Stake({
            challengeId: challengeId,
            amount: amount,
            timestamp: block.timestamp,
            isHardcore: isHardcore,
            isCompleted: false,
            isFailed: false
        });
        
        // Add to user's active challenges
        userActiveChallenges[msg.sender].push(challengeId);
        
        // Update total staked amount
        totalStaked += amount;
        
        emit StakeReceived(msg.sender, challengeId, amount, isHardcore);
    }
    
    /**
     * @dev Completes a challenge and distributes rewards to the user
     * @param user The address of the user who completed the challenge
     * @param challengeId The unique identifier of the completed challenge
     * @param yieldPercentage The yield percentage earned (in basis points, e.g. 500 = 5%)
     */
    function completeChallenge(address user, string memory challengeId, uint256 yieldPercentage) external onlyOwner nonReentrant {
        Stake storage stake = stakes[user][challengeId];
        
        require(stake.amount > 0, "No stake found for this challenge");
        require(!stake.isCompleted && !stake.isFailed, "Challenge already completed or failed");
        
        // Calculate reward with yield
        uint256 yield = (stake.amount * yieldPercentage) / 10000; // Convert basis points to percentage
        uint256 reward = stake.amount + yield;
        
        // Transfer reward to user
        require(usdcToken.transfer(user, reward), "Reward transfer failed");
        
        // Update stake status
        stake.isCompleted = true;
        
        // Remove from active challenges
        _removeActiveChallenge(user, challengeId);
        
        // Update totals
        totalStaked -= stake.amount;
        totalYieldGenerated += yield;
        
        emit ChallengeCompleted(user, challengeId, reward);
    }
    
    /**
     * @dev Marks a challenge as failed (for hardcore challenges)
     * @param user The address of the user who failed the challenge
     * @param challengeId The unique identifier of the failed challenge
     */
    function failChallenge(address user, string memory challengeId) external onlyOwner nonReentrant {
        Stake storage stake = stakes[user][challengeId];
        
        require(stake.amount > 0, "No stake found for this challenge");
        require(!stake.isCompleted && !stake.isFailed, "Challenge already completed or failed");
        require(stake.isHardcore, "Only hardcore challenges can be failed");
        
        // Update stake status
        stake.isFailed = true;
        
        // Remove from active challenges
        _removeActiveChallenge(user, challengeId);
        
        // For hardcore challenges, the stake is forfeited (stays in contract)
        // No token transfer needed
        
        emit ChallengeFailed(user, challengeId);
    }
    
    /**
     * @dev Allows user to withdraw stake for non-hardcore challenges if they decide to quit
     * @param challengeId The unique identifier of the challenge to withdraw from
     */
    function withdrawFromChallenge(string memory challengeId) external nonReentrant {
        Stake storage stake = stakes[msg.sender][challengeId];
        
        require(stake.amount > 0, "No stake found for this challenge");
        require(!stake.isCompleted && !stake.isFailed, "Challenge already completed or failed");
        require(!stake.isHardcore, "Cannot withdraw from hardcore challenges");
        
        // Transfer stake back to user
        require(usdcToken.transfer(msg.sender, stake.amount), "Stake transfer failed");
        
        // Update stake status
        stake.isFailed = true; // Mark as failed (quit)
        
        // Remove from active challenges
        _removeActiveChallenge(msg.sender, challengeId);
        
        // Update total staked amount
        totalStaked -= stake.amount;
        
        emit ChallengeFailed(msg.sender, challengeId);
    }
    
    /**
     * @dev Allows owner to withdraw yield for protocol fees/operations
     * @param amount The amount of USDC to withdraw
     */
    function withdrawYield(uint256 amount) external onlyOwner nonReentrant {
        require(amount <= usdcToken.balanceOf(address(this)) - totalStaked, "Cannot withdraw staked funds");
        
        require(usdcToken.transfer(owner(), amount), "Yield transfer failed");
    }
    
    /**
     * @dev Deactivates a challenge to prevent new stakes
     * @param challengeId The unique identifier of the challenge
     */
    function deactivateChallenge(string memory challengeId) external nonReentrant {
        Challenge storage challenge = challenges[challengeId];
        
        require(challenge.createdAt > 0, "Challenge does not exist");
        require(msg.sender == challenge.creator || msg.sender == owner(), "Only creator or owner can deactivate");
        
        challenge.isActive = false;
    }
    
    /**
     * @dev Helper function to remove a challenge from user's active challenges
     */
    function _removeActiveChallenge(address user, string memory challengeId) internal {
        string[] storage activeChallenges = userActiveChallenges[user];
        
        for (uint256 i = 0; i < activeChallenges.length; i++) {
            if (keccak256(bytes(activeChallenges[i])) == keccak256(bytes(challengeId))) {
                // Replace with the last element and pop
                activeChallenges[i] = activeChallenges[activeChallenges.length - 1];
                activeChallenges.pop();
                break;
            }
        }
    }
    
    /**
     * @dev Returns the stake details for a given user and challenge
     */
    function getStake(address user, string memory challengeId) external view returns (
        uint256 amount,
        uint256 timestamp,
        bool isHardcore,
        bool isCompleted,
        bool isFailed
    ) {
        Stake memory stake = stakes[user][challengeId];
        return (
            stake.amount,
            stake.timestamp,
            stake.isHardcore,
            stake.isCompleted,
            stake.isFailed
        );
    }
    
    /**
     * @dev Returns all active challenges for a user
     */
    function getUserActiveChallenges(address user) external view returns (string[] memory) {
        return userActiveChallenges[user];
    }
    
    /**
     * @dev Returns challenge details
     */
    function getChallengeDetails(string memory challengeId) external view returns (
        uint256 stakeAmount,
        uint256 yieldBps,
        bool isHardcore,
        uint256 durationDays,
        bool isActive,
        address creator,
        uint256 createdAt
    ) {
        Challenge memory challenge = challenges[challengeId];
        return (
            challenge.stakeAmount,
            challenge.yieldBps,
            challenge.isHardcore,
            challenge.durationDays,
            challenge.isActive,
            challenge.creator,
            challenge.createdAt
        );
    }
}

================
File: lib/auth/jwt.js
================
// File: lib/auth/jwt.js
import { jwtVerify, SignJWT } from 'jose';

// Function to verify JWT
export async function verifyJWT(token) {
  if (!process.env.JWT_SECRET) {
    throw new Error('JWT_SECRET is not defined');
  }
  
  const secret = new TextEncoder().encode(process.env.JWT_SECRET);
  
  try {
    const { payload } = await jwtVerify(token, secret);
    return payload;
  } catch (error) {
    throw new Error('Invalid token');
  }
}

// Function to create JWT
export async function createJWT(payload) {
  if (!process.env.JWT_SECRET) {
    throw new Error('JWT_SECRET is not defined');
  }
  
  const secret = new TextEncoder().encode(process.env.JWT_SECRET);
  
  const jwt = await new SignJWT(payload)
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(secret);
  
  return jwt;
}

================
File: lib/auth/verify.js
================
// File: lib/auth/verify.js
import { cookies } from 'next/headers';
import { jwtVerify } from 'jose';

export async function verifyAuth() {
  try {
    const cookieStore = await cookies();
    const token = cookieStore.get('auth_token')?.value;
    
    if (!token) {
      return { success: false, error: 'No authentication token' };
    }
    
    const secret = new TextEncoder().encode(process.env.JWT_SECRET);
    const { payload } = await jwtVerify(token, secret);
    
    if (!payload.userId || !payload.walletAddress) {
      return { success: false, error: 'Invalid token payload' };
    }
    
    return {
      success: true,
      userId: payload.userId,
      walletAddress: payload.walletAddress
    };
  } catch (error) {
    console.error('Auth verification error:', error);
    return { success: false, error: 'Authentication failed' };
  }
}

================
File: lib/cron/dailyCheck.js
================
// lib/cron/dailyCheck.js
import { PrismaClient } from '@prisma/client';
import { sendEmail } from '../email/sender';

const prisma = new PrismaClient();

export async function runDailyChecks() {
  console.log('Running daily checks at', new Date().toISOString());
  
  try {
    // Get all active challenges
    const activeChallenges = await prisma.userChallenge.findMany({
      where: { status: 'ACTIVE' },
      include: {
        user: true,
        challenge: true,
        dailyProgress: {
          orderBy: { date: 'desc' },
          take: 1
        }
      }
    });
    
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    // Process each active challenge
    for (const userChallenge of activeChallenges) {
      try {
        // Check if the end date has passed
        const endDate = new Date(userChallenge.endDate);
        if (endDate < today) {
          // Challenge has ended, determine if completed or failed
          await processChallengeCompletion(userChallenge);
          continue;
        }
        
        // Check if user has practiced today
        const hasPracticedToday = userChallenge.dailyProgress.some(progress => {
          const progressDate = new Date(progress.date);
          progressDate.setHours(0, 0, 0, 0);
          return progressDate.getTime() === today.getTime() && progress.completed;
        });
        
        if (!hasPracticedToday) {
          // Send reminder notification
          await sendPracticeReminder(userChallenge);
        }
        
        // Check streak - if zero and challenge requires streaks, issue warning
        if (userChallenge.currentStreak === 0 && userChallenge.challenge.isHardcore) {
          await sendStreakWarning(userChallenge);
        }
      } catch (error) {
        console.error(`Error processing challenge ${userChallenge.id}:`, error);
      }
    }
    
    console.log('Daily checks completed');
  } catch (error) {
    console.error('Error running daily checks:', error);
  }
}

async function processChallengeCompletion(userChallenge) {
  // Calculate completion percentage
  const totalDays = userChallenge.challenge.durationDays;
  const completedDays = await prisma.dailyProgress.count({
    where: {
      userChallengeId: userChallenge.id,
      completed: true
    }
  });
  
  const completionPercentage = (completedDays / totalDays) * 100;
  
  // Update progress percentage
  await prisma.userChallenge.update({
    where: { id: userChallenge.id },
    data: { progressPercentage: completionPercentage }
  });
  
  // Check if challenge is successful
  // For simplicity, we'll say a challenge is complete if the user has completed at least 80% of the days
  const completionThreshold = Math.floor(totalDays * 0.8);
  
  if (completedDays >= completionThreshold) {
    // Mark challenge as completed
    await prisma.userChallenge.update({
      where: { id: userChallenge.id },
      data: { status: 'COMPLETED' }
    });
    
    // Create notification
    await prisma.notification.create({
      data: {
        userId: userChallenge.userId,
        type: 'CHALLENGE_COMPLETED',
        title: 'Challenge Completed!',
        message: `Congratulations! You've completed the "${userChallenge.challenge.title}" challenge. Claim your rewards now.`,
        read: false
      }
    });
    
    // Send email notification
    await sendEmail(
      userChallenge.user.email,
      'Challenge Completed!',
      `Congratulations! You've completed the "${userChallenge.challenge.title}" challenge. Claim your rewards now.`
    );
  } else if (userChallenge.challenge.isHardcore) {
    // For hardcore challenges, mark as failed if completion < threshold
    await prisma.userChallenge.update({
      where: { id: userChallenge.id },
      data: { status: 'FAILED' }
    });
    
    // Create notification
    await prisma.notification.create({
      data: {
        userId: userChallenge.userId,
        type: 'CHALLENGE_FAILED',
        title: 'Challenge Failed',
        message: `Unfortunately, you didn't meet the requirements for the "${userChallenge.challenge.title}" challenge. Your stake has been forfeited.`,
        read: false
      }
    });
  } else {
    // For no-loss challenges, just mark as completed with partial success
    await prisma.userChallenge.update({
      where: { id: userChallenge.id },
      data: { status: 'COMPLETED' }
    });
    
    // Create notification
    await prisma.notification.create({
      data: {
        userId: userChallenge.userId,
        type: 'CHALLENGE_COMPLETED',
        title: 'Challenge Completed',
        message: `Your "${userChallenge.challenge.title}" challenge has ended. You completed ${completedDays} out of ${totalDays} days. Claim your stake now.`,
        read: false
      }
    });
  }
}

async function sendPracticeReminder(userChallenge) {
  // Create reminder notification
  await prisma.notification.create({
    data: {
      userId: userChallenge.userId,
      type: 'CHALLENGE_REMINDER',
      title: 'Daily Practice Reminder',
      message: `Don't forget to practice ${userChallenge.challenge.dailyRequirement} minutes of ${getLanguageName(userChallenge.challenge.languageCode)} today to maintain your streak!`,
      read: false
    }
  });
  
  // Optionally send email if user has email notifications enabled
  if (userChallenge.user.email) {
    await sendEmail(
      userChallenge.user.email,
      'Daily Practice Reminder',
      `Don't forget to practice ${userChallenge.challenge.dailyRequirement} minutes of ${getLanguageName(userChallenge.challenge.languageCode)} today to maintain your streak!`
    );
  }
}

async function sendStreakWarning(userChallenge) {
  // Create streak warning notification
  await prisma.notification.create({
    data: {
      userId: userChallenge.userId,
      type: 'STREAK_WARNING',
      title: 'Streak Warning',
      message: `Your streak for the "${userChallenge.challenge.title}" challenge is at risk! Practice today to avoid losing your stake.`,
      read: false
    }
  });
  
  // Optionally send email if user has email notifications enabled
  if (userChallenge.user.email) {
    await sendEmail(
      userChallenge.user.email,
      'Streak Warning',
      `Your streak for the "${userChallenge.challenge.title}" challenge is at risk! Practice today to avoid losing your stake.`
    );
  }
}

// Helper function to get language name
function getLanguageName(code) {
  const languages = {
    'en': 'English',
    'es': 'Spanish',
    'fr': 'French',
    'de': 'German',
    'it': 'Italian',
    'ja': 'Japanese',
    'ko': 'Korean',
    'zh': 'Chinese',
    'ru': 'Russian',
    'pt': 'Portuguese',
    'ar': 'Arabic',
    'hi': 'Hindi'
  };
  
  return languages[code] || code;
}

================
File: lib/web3/abis/stakingABI.json
================
[
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_usdcToken",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "yieldBps",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        }
      ],
      "name": "ChallengeRegistered",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        }
      ],
      "name": "ChallengeCompleted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "ChallengeFailed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "previousOwner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "OwnershipTransferred",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "staker",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        }
      ],
      "name": "StakeReceived",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "challenges",
      "outputs": [
        {
          "internalType": "string",
          "name": "id",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "yieldBps",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "durationDays",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isActive",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "createdAt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "yieldPercentage",
          "type": "uint256"
        }
      ],
      "name": "completeChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "deactivateChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "failChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "getChallengeDetails",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "yieldBps",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "durationDays",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isActive",
          "type": "bool"
        },
        {
          "internalType": "address",
          "name": "creator",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "createdAt",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "getStake",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isCompleted",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isFailed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "user",
          "type": "address"
        }
      ],
      "name": "getUserActiveChallenges",
      "outputs": [
        {
          "internalType": "string[]",
          "name": "",
          "type": "string[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "owner",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "stakeAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "yieldBps",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        },
        {
          "internalType": "uint256",
          "name": "durationDays",
          "type": "uint256"
        }
      ],
      "name": "registerChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        }
      ],
      "name": "stakeForChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "name": "stakes",
      "outputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "timestamp",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "isHardcore",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isCompleted",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "isFailed",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalChallenges",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalStaked",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalYieldGenerated",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "newOwner",
          "type": "address"
        }
      ],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "userActiveChallenges",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "usdcToken",
      "outputs": [
        {
          "internalType": "contract IERC20",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "challengeId",
          "type": "string"
        }
      ],
      "name": "withdrawFromChallenge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawYield",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ]

================
File: lib/web3/abis/usdcABI.json
================
[
  {
    "constant": true,
    "inputs": [],
    "name": "name",
    "outputs": [{"name": "", "type": "string"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}],
    "name": "approve",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "totalSupply",
    "outputs": [{"name": "", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{"name": "_from", "type": "address"}, {"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}],
    "name": "transferFrom",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "decimals",
    "outputs": [{"name": "", "type": "uint8"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}],
    "name": "balanceOf",
    "outputs": [{"name": "balance", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [],
    "name": "symbol",
    "outputs": [{"name": "", "type": "string"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "constant": false,
    "inputs": [{"name": "_to", "type": "address"}, {"name": "_value", "type": "uint256"}],
    "name": "transfer",
    "outputs": [{"name": "", "type": "bool"}],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "function"
  },
  {
    "constant": true,
    "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}],
    "name": "allowance",
    "outputs": [{"name": "", "type": "uint256"}],
    "payable": false,
    "stateMutability": "view",
    "type": "function"
  },
  {
    "inputs": [],
    "payable": false,
    "stateMutability": "nonpayable",
    "type": "constructor"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "owner", "type": "address"},
      {"indexed": true, "name": "spender", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Approval",
    "type": "event"
  },
  {
    "anonymous": false,
    "inputs": [
      {"indexed": true, "name": "from", "type": "address"},
      {"indexed": true, "name": "to", "type": "address"},
      {"indexed": false, "name": "value", "type": "uint256"}
    ],
    "name": "Transfer",
    "type": "event"
  }
]

================
File: lib/web3/hooks/useContract.js
================
// lib/web3/hooks/useContract.js
import { useEffect, useState } from 'react';
import { ethers } from 'ethers';
import stakingABI from '../abis/stakingABI.json';
import usdcABI from '../abis/usdcABI.json';

const STAKING_CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_STAKING_CONTRACT_ADDRESS;
const USDC_CONTRACT_ADDRESS = process.env.NEXT_PUBLIC_USDC_CONTRACT_ADDRESS;

export function useContract() {
  const [stakingContract, setStakingContract] = useState(null);
  const [usdcContract, setUsdcContract] = useState(null);
  const [provider, setProvider] = useState(null);
  const [signer, setSigner] = useState(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const initializeProvider = async () => {
      try {
        setIsLoading(true);
        setError(null);

        // Initialize provider
        if (typeof window !== 'undefined' && window.ethereum) {
          const ethProvider = new ethers.BrowserProvider(window.ethereum);
          setProvider(ethProvider);

          try {
            // Get signer (will prompt user to connect if not already connected)
            const ethSigner = await ethProvider.getSigner();
            setSigner(ethSigner);
            setIsConnected(true);

            // Initialize contract instances
            const newStakingContract = new ethers.Contract(
              STAKING_CONTRACT_ADDRESS,
              stakingABI,
              ethSigner
            );
            setStakingContract(newStakingContract);

            const newUsdcContract = new ethers.Contract(
              USDC_CONTRACT_ADDRESS,
              usdcABI,
              ethSigner
            );
            setUsdcContract(newUsdcContract);
          } catch (signerError) {
            // This might happen if user rejects connection - that's ok
            console.log("Signer not available:", signerError.message);
            
            // Still set up read-only contracts with provider
            const newStakingContract = new ethers.Contract(
              STAKING_CONTRACT_ADDRESS,
              stakingABI,
              ethProvider
            );
            setStakingContract(newStakingContract);

            const newUsdcContract = new ethers.Contract(
              USDC_CONTRACT_ADDRESS,
              usdcABI,
              ethProvider
            );
            setUsdcContract(newUsdcContract);
            setIsConnected(false);
          }
        } else {
          setError('No Ethereum provider detected. Please install MetaMask or similar.');
          setIsConnected(false);
        }
      } catch (err) {
        console.error('Error initializing contracts:', err);
        setError(err.message || 'Failed to initialize contracts');
      } finally {
        setIsLoading(false);
      }
    };

    initializeProvider();

    // Set up event listeners for account changes
    if (typeof window !== 'undefined' && window.ethereum) {
      const handleAccountsChanged = () => {
        // Reinitialize on account change
        initializeProvider();
      };

      window.ethereum.on('accountsChanged', handleAccountsChanged);
      window.ethereum.on('chainChanged', handleAccountsChanged);

      return () => {
        window.ethereum.removeListener('accountsChanged', handleAccountsChanged);
        window.ethereum.removeListener('chainChanged', handleAccountsChanged);
      };
    }
  }, []);

  return {
    stakingContract,
    usdcContract,
    provider,
    signer,
    isConnected,
    isLoading,
    error,
  };
}

================
File: lib/web3/hooks/useStaking.js
================
// lib/web3/hooks/useStaking.js
import { useState, useCallback } from 'react';
import { ethers } from 'ethers';
import { useContract } from './useContract';

export function useStaking() {
  const { stakingContract, usdcContract, isConnected, signer } = useContract();
  const [isStaking, setIsStaking] = useState(false);
  const [stakingError, setStakingError] = useState(null);
  const [stakingSuccess, setStakingSuccess] = useState(false);
  const [transaction, setTransaction] = useState(null);

  // Function to approve USDC for spending by the staking contract
  const approveUSDC = useCallback(async (amount) => {
    if (!usdcContract || !isConnected) {
      throw new Error('Wallet not connected or contract not initialized');
    }

    try {
      setStakingError(null);
      // Convert amount to USDC units (6 decimals)
      const usdcAmount = ethers.parseUnits(amount.toString(), 6);
      
      // Approve staking contract to spend USDC
      const tx = await usdcContract.approve(stakingContract.target, usdcAmount);
      await tx.wait();
      return tx.hash;
    } catch (error) {
      console.error('Error approving USDC:', error);
      throw error;
    }
  }, [usdcContract, stakingContract, isConnected]);

  // Function to stake USDC for a challenge
  const stakeForChallenge = useCallback(async (challengeId, amount, isHardcore) => {
    if (!stakingContract || !isConnected) {
      setStakingError('Wallet not connected or contract not initialized');
      return null;
    }

    try {
      setIsStaking(true);
      setStakingError(null);
      setStakingSuccess(false);
      
      // First approve USDC spending
      try {
        await approveUSDC(amount);
      } catch (approvalError) {
        setStakingError(`Failed to approve USDC: ${approvalError.message}`);
        setIsStaking(false);
        return null;
      }
      
      // Then stake for the challenge
      const usdcAmount = ethers.parseUnits(amount.toString(), 6);
      
      const tx = await stakingContract.stakeForChallenge(
        challengeId,
        usdcAmount,
        isHardcore,
        { gasLimit: 300000 }
      );
      
      // Wait for transaction to be mined
      const receipt = await tx.wait();
      
      // Store transaction details
      setTransaction({
        hash: receipt.hash,
        status: receipt.status ? 'success' : 'failed',
        amount,
        challengeId
      });
      
      if (receipt.status) {
        setStakingSuccess(true);
        return receipt.hash;
      } else {
        setStakingError('Transaction failed');
        return null;
      }
    } catch (error) {
      console.error('Error staking for challenge:', error);
      setStakingError(error.message || 'Failed to stake for challenge');
      return null;
    } finally {
      setIsStaking(false);
    }
  }, [stakingContract, approveUSDC, isConnected]);

  // Function to withdraw from a non-hardcore challenge
  const withdrawFromChallenge = useCallback(async (challengeId) => {
    if (!stakingContract || !isConnected) {
      setStakingError('Wallet not connected or contract not initialized');
      return null;
    }

    try {
      setIsStaking(true);
      setStakingError(null);
      setStakingSuccess(false);
      
      const tx = await stakingContract.withdrawFromChallenge(
        challengeId,
        { gasLimit: 300000 }
      );
      
      const receipt = await tx.wait();
      
      setTransaction({
        hash: receipt.hash,
        status: receipt.status ? 'success' : 'failed',
        challengeId
      });
      
      if (receipt.status) {
        setStakingSuccess(true);
        return receipt.hash;
      } else {
        setStakingError('Transaction failed');
        return null;
      }
    } catch (error) {
      console.error('Error withdrawing from challenge:', error);
      setStakingError(error.message || 'Failed to withdraw from challenge');
      return null;
    } finally {
      setIsStaking(false);
    }
  }, [stakingContract, isConnected]);

  // Get user's active challenges
  const getUserActiveChallenges = useCallback(async (userAddress) => {
    if (!stakingContract) return [];
    
    try {
      const challenges = await stakingContract.getUserActiveChallenges(userAddress);
      return challenges;
    } catch (error) {
      console.error('Error getting active challenges:', error);
      return [];
    }
  }, [stakingContract]);

  // Get stake details for a challenge
  const getStakeDetails = useCallback(async (userAddress, challengeId) => {
    if (!stakingContract) return null;
    
    try {
      const [amount, timestamp, isHardcore, isCompleted, isFailed] = 
        await stakingContract.getStake(userAddress, challengeId);
      
      return {
        amount: ethers.formatUnits(amount, 6), // Convert from USDC units
        timestamp: new Date(Number(timestamp) * 1000),
        isHardcore,
        isCompleted,
        isFailed
      };
    } catch (error) {
      console.error('Error getting stake details:', error);
      return null;
    }
  }, [stakingContract]);

  return {
    stakeForChallenge,
    withdrawFromChallenge,
    getUserActiveChallenges,
    getStakeDetails,
    isStaking,
    stakingError,
    stakingSuccess,
    transaction,
    approveUSDC
  };
}

// lib/web3/hooks/useYield.js
import { useState, useEffect, useCallback } from 'react';
import { ethers } from 'ethers';
import { useContract } from './useContract';

// This hook manages the yield calculation and projection
export function useYield(stakedAmount, yieldPercentage, durationDays) {
  const [projectedReward, setProjectedReward] = useState(0);
  const [dailyYield, setDailyYield] = useState(0);
  const [apy, setApy] = useState(0);
  
  useEffect(() => {
    if (!stakedAmount || !yieldPercentage || !durationDays) {
      setProjectedReward(0);
      setDailyYield(0);
      setApy(0);
      return;
    }
    
    // Calculate projected reward
    const yieldAmount = (parseFloat(stakedAmount) * parseFloat(yieldPercentage)) / 100;
    const totalReward = parseFloat(stakedAmount) + yieldAmount;
    setProjectedReward(totalReward);
    
    // Calculate daily yield
    const daily = yieldAmount / durationDays;
    setDailyYield(daily);
    
    // Calculate APY
    const yearlyYield = (yieldAmount / durationDays) * 365;
    const calculatedApy = (yearlyYield / parseFloat(stakedAmount)) * 100;
    setApy(calculatedApy);
  }, [stakedAmount, yieldPercentage, durationDays]);
  
  return {
    projectedReward,
    dailyYield,
    apy
  };
}

// lib/web3/abis/usdcABI.json would need to be created as a separate file

================
File: lib/web3/providers.js
================
// lib/web3/providers.js
import { ethers } from "ethers";

// Function to get Ethereum provider
export const getEthereumProvider = async () => {
  // Check if window is defined (browser environment)
  if (typeof window !== 'undefined' && window.ethereum) {
    try {
      // Request account access
      await window.ethereum.request({ method: 'eth_requestAccounts' });
      return new ethers.BrowserProvider(window.ethereum);
    } catch (error) {
      console.error('User denied account access:', error);
      throw new Error('User denied account access');
    }
  } else {
    throw new Error('No Ethereum browser extension detected. Please install MetaMask or similar.');
  }
};

// Function to get connected wallet address
export const getWalletAddress = async () => {
  try {
    const provider = await getEthereumProvider();
    const signer = await provider.getSigner();
    return await signer.getAddress();
  } catch (error) {
    console.error('Error getting wallet address:', error);
    throw error;
  }
};

// Function to sign a message with wallet
export const signMessage = async (message) => {
  try {
    const provider = await getEthereumProvider();
    const signer = await provider.getSigner();
    return await signer.signMessage(message);
  } catch (error) {
    console.error('Error signing message:', error);
    throw error;
  }
};

================
File: lib/web3/staking.js
================
// lib/web3/staking.js
import { ethers } from 'ethers';
import stakingABI from './abis/stakingABI.json';

const STAKING_CONTRACT_ADDRESS = process.env.STAKING_CONTRACT_ADDRESS;
const USDC_CONTRACT_ADDRESS = process.env.USDC_CONTRACT_ADDRESS;
const PROVIDER_URL = process.env.PROVIDER_URL;

export async function processStaking(transactionHash, amount, userWalletAddress) {
  try {
    // Connect to the blockchain
    const provider = new ethers.JsonRpcProvider(PROVIDER_URL);
    
    // Get transaction receipt
    const receipt = await provider.getTransactionReceipt(transactionHash);
    
    if (!receipt || !receipt.status) {
      return { success: false, error: 'Transaction failed or not found' };
    }
    
    // Get transaction
    const transaction = await provider.getTransaction(transactionHash);
    
    // Verify it's interacting with our staking contract
    if (transaction.to.toLowerCase() !== STAKING_CONTRACT_ADDRESS.toLowerCase()) {
      return { success: false, error: 'Transaction is not interacting with the staking contract' };
    }
    
    // Decode the transaction data to verify it's a staking function and the correct amount
    const stakingContract = new ethers.Contract(
      STAKING_CONTRACT_ADDRESS,
      stakingABI,
      provider
    );
    
    // Look for relevant events in the logs
    const stakingEvents = receipt.logs
      .filter(log => log.address.toLowerCase() === STAKING_CONTRACT_ADDRESS.toLowerCase())
      .map(log => {
        try {
          return stakingContract.interface.parseLog(log);
        } catch (e) {
          return null;
        }
      })
      .filter(event => event && event.name === 'StakeReceived');
    
    if (stakingEvents.length === 0) {
      return { success: false, error: 'No staking event found in transaction' };
    }
    
    // Verify the event details
    const stakingEvent = stakingEvents[0];
    const eventStaker = stakingEvent.args.staker.toLowerCase();
    const eventAmount = stakingEvent.args.amount;
    
    if (eventStaker !== userWalletAddress.toLowerCase()) {
      return { success: false, error: 'Staker address does not match user wallet' };
    }
    
    // Convert amounts for comparison (USDC has 6 decimals)
    const expectedAmount = ethers.parseUnits(amount.toString(), 6);
    
    if (!eventAmount.eq(expectedAmount)) {
      return { success: false, error: 'Staked amount does not match required amount' };
    }
    
    return { success: true, transactionHash };
  } catch (error) {
    console.error('Error verifying staking transaction:', error);
    return { success: false, error: 'Failed to verify staking transaction' };
  }
}
export async function processUnstaking(userChallengeId, userId, walletAddress) {
    try {
      // Get user challenge data
      const userChallenge = await prisma.userChallenge.findUnique({
        where: { 
          id: userChallengeId,
          userId
        },
        include: {
          challenge: true
        }
      });
      
      if (!userChallenge) {
        return { success: false, error: 'Challenge not found' };
      }
      
      // Connect to provider
      const provider = new ethers.JsonRpcProvider(PROVIDER_URL);
      
      // Load private key from environment variables (securely stored)
      const privateKey = process.env.STAKING_ADMIN_PRIVATE_KEY;
      if (!privateKey) {
        return { success: false, error: 'Missing contract admin credentials' };
      }
      
      // Create signer
      const signer = new ethers.Wallet(privateKey, provider);
      
      // Initialize contract
      const stakingContract = new ethers.Contract(
        STAKING_CONTRACT_ADDRESS,
        stakingABI,
        signer
      );
      
      // For non-hardcore challenges, call withdrawFromChallenge
      if (!userChallenge.challenge.isHardcore) {
        // Prepare transaction
        const tx = await stakingContract.withdrawFromChallenge(
          userChallenge.id, // Use challenge ID as identifier
          walletAddress, // User's wallet address
          { gasLimit: 300000 }
        );
        
        // Wait for transaction to be mined
        const receipt = await tx.wait();
        
        if (!receipt || !receipt.status) {
          return { success: false, error: 'Transaction failed' };
        }
        
        return { 
          success: true, 
          transactionHash: receipt.hash,
          amount: userChallenge.stakedAmount
        };
      } else {
        return { success: false, error: 'Cannot unstake from hardcore challenges' };
      }
    } catch (error) {
      console.error('Error processing unstaking:', error);
      return { success: false, error: 'Failed to process unstaking' };
    }
  }
  
// Enhanced implementation of processRewardDistribution function
export async function processRewardDistribution(userChallengeId, userId, walletAddress, rewardAmount) {
  try {
    // Get user challenge data
    const userChallenge = await prisma.userChallenge.findUnique({
      where: { 
        id: userChallengeId,
        userId
      },
      include: {
        challenge: true
      }
    });
    
    if (!userChallenge) {
      return { success: false, error: 'Challenge not found' };
    }
    
    // Check if there's already a transaction hash for this challenge
    if (userChallenge.completionTxHash) {
      // Verify if the transaction was successful
      try {
        const provider = new ethers.JsonRpcProvider(PROVIDER_URL);
        const receipt = await provider.getTransactionReceipt(userChallenge.completionTxHash);
        
        if (receipt && receipt.status) {
          return { 
            success: true, 
            transactionHash: userChallenge.completionTxHash,
            alreadyProcessed: true
          };
        }
      } catch (txCheckError) {
        console.error('Error checking existing transaction:', txCheckError);
        // If we can't verify, continue with creating a new transaction
      }
    }
    
    // Connect to provider
    const provider = new ethers.JsonRpcProvider(PROVIDER_URL);
    
    // Load private key from environment variables (securely stored)
    const privateKey = process.env.STAKING_ADMIN_PRIVATE_KEY;
    if (!privateKey) {
      return { success: false, error: 'Missing contract admin credentials' };
    }
    
    // Create signer
    const signer = new ethers.Wallet(privateKey, provider);
    
    // Initialize contract
    const stakingContract = new ethers.Contract(
      STAKING_CONTRACT_ADDRESS,
      stakingABI,
      signer
    );
    
    // Check contract balance to ensure it has enough USDC to pay out
    const usdcContract = new ethers.Contract(
      USDC_CONTRACT_ADDRESS,
      usdcABI,
      provider
    );
    
    const contractBalance = await usdcContract.balanceOf(STAKING_CONTRACT_ADDRESS);
    const requiredAmount = ethers.parseUnits(rewardAmount.toString(), 6); // USDC has 6 decimals
    
    if (contractBalance < requiredAmount) {
      return { success: false, error: 'Insufficient contract balance for reward distribution' };
    }
    
    // Calculate yield percentage in basis points (e.g., 5% = 500 basis points)
    const yieldPercentage = Math.round(userChallenge.challenge.yieldPercentage * 100);
    
    // Add retry logic for transaction
    let attempts = 0;
    const maxAttempts = 3;
    let lastError = null;
    
    while (attempts < maxAttempts) {
      try {
        console.log(`Attempt ${attempts + 1} to complete challenge ${userChallengeId}`);
        
        // Call completeChallenge function
        const tx = await stakingContract.completeChallenge(
          walletAddress, // User's wallet address
          userChallenge.challengeId, // Challenge ID
          yieldPercentage, // Yield in basis points
          { 
            gasLimit: 500000,
            // Increment gas price slightly on retries to help with stuck transactions
            maxFeePerGas: attempts > 0 ? undefined : undefined, // Will use market rate on first try
            maxPriorityFeePerGas: attempts > 0 ? (1000000000 * (attempts + 1)) : undefined // Increment priority fee on retries
          }
        );
        
        console.log(`Transaction submitted: ${tx.hash}`);
        
        // Wait for transaction to be mined
        const receipt = await tx.wait();
        
        if (!receipt || !receipt.status) {
          throw new Error('Transaction failed');
        }
        
        // Find ChallengeCompleted event
        const completeEvent = receipt.logs
          .filter(log => log.address.toLowerCase() === STAKING_CONTRACT_ADDRESS.toLowerCase())
          .map(log => {
            try {
              return stakingContract.interface.parseLog(log);
            } catch (e) {
              return null;
            }
          })
          .filter(event => event && event.name === 'ChallengeCompleted')[0];
        
        if (!completeEvent) {
          throw new Error('No completion event found in transaction');
        }
        
        return { 
          success: true, 
          transactionHash: receipt.hash,
          reward: rewardAmount
        };
      } catch (error) {
        console.error(`Attempt ${attempts + 1} failed:`, error);
        lastError = error;
        attempts++;
        
        // Wait before retrying
        if (attempts < maxAttempts) {
          await new Promise(resolve => setTimeout(resolve, 5000 * attempts)); // Incremental backoff
        }
      }
    }
    
    return { success: false, error: lastError?.message || 'Failed to process reward distribution after multiple attempts' };
  } catch (error) {
    console.error('Error processing reward distribution:', error);
    return { success: false, error: 'Failed to process reward distribution' };
  }
}

================
File: lib/utils.js
================
import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}

================
File: prisma/schema.prisma
================
// This is your Prisma schema file for ShinobiSpeak

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User management
model User {
  id                String            @id @default(uuid())
  walletAddress     String            @unique
  username          String?
  email             String?           @unique
  avatarUrl         String?
  createdAt         DateTime          @default(now())
  updatedAt         DateTime          @updatedAt
  
  // User profile data
  nativeLanguage    String?
  learningLanguages UserLanguage[]
  
  // Relationships
  challenges        UserChallenge[]   // Challenges the user is participating in
  createdChallenges Challenge[]       // Challenges created by the user
  aiConversations   AIConversation[]  // History of AI conversations
  progressRecords   ProgressRecord[]  // User's learning progress
  achievements      UserAchievement[]
  notifications     Notification[]
  transactions      Transaction[]
  lessons            LessonCompletion[]
  
  
  @@index([walletAddress])
}

model UserLanguage {
  id              String          @id @default(uuid())
  userId          String
  languageCode    String          // ISO code (e.g., "en", "jp", "es")
  proficiencyLevel ProficiencyLevel
  startedAt       DateTime        @default(now())
  lastPracticed    DateTime?
  
  // Relationships
  user            User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([userId, languageCode])
}

enum ProficiencyLevel {
  BEGINNER
  ELEMENTARY
  INTERMEDIATE
  ADVANCED
  FLUENT
}

// Challenge system
model Challenge {
  id                String          @id @default(uuid())
  title             String
  description       String
  languageCode      String
  proficiencyLevel  ProficiencyLevel
  durationDays      Int
  dailyRequirement  Int             // Minutes of practice required daily
  stakeAmount       Float           // Amount in USDC to stake
  yieldPercentage   Float           // Expected yield percentage
  isHardcore        Boolean         // If true, stake is lost on failure
  maxParticipants   Int?            // Optional max number of participants
  inviteCode        String?         // Optional invite code for private challenges
  creatorId         String
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Smart contract data
  contractAddress   String?
  contractChain     String?         // e.g., "ethereum", "polygon"
  
  // Relationships
  creator           User            @relation(fields: [creatorId], references: [id])
  participants      UserChallenge[]
  lessons           Lesson[]
  
  @@index([languageCode, proficiencyLevel])
  @@index([isActive])
}

model UserChallenge {
  id                String          @id @default(uuid())
  userId            String
  challengeId       String
  startDate         DateTime        @default(now())
  endDate           DateTime?
  stakedAmount      Float           // Actual amount staked (in USDC)
  currentStreak     Int             @default(0)  // Current consecutive days
  longestStreak     Int             @default(0)  // Longest consecutive days
  progressPercentage Float          @default(0)  // 0-100
  status            ChallengeStatus @default(ACTIVE)
  
  // Transaction data
  stakeTxHash       String?         // Transaction hash for staking
  completionTxHash  String?         // Transaction hash for completion/reward
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  challenge         Challenge       @relation(fields: [challengeId], references: [id])
  dailyProgress     DailyProgress[]
  
  @@unique([userId, challengeId])
  @@index([status])
}

enum ChallengeStatus {
  ACTIVE
  COMPLETED
  FAILED
  WITHDRAWN
}

model DailyProgress {
  id                String          @id @default(uuid())
  userChallengeId   String
  date              DateTime        @default(now())
  minutesPracticed  Int
  completed         Boolean         @default(false)
  
  // Relationships
  userChallenge     UserChallenge   @relation(fields: [userChallengeId], references: [id], onDelete: Cascade)
  
  @@unique([userChallengeId, date])
}

// Learning content
model Lesson {
  id                String          @id @default(uuid())
  title             String
  description       String
  challengeId       String?
  languageCode      String
  proficiencyLevel  ProficiencyLevel
  estimatedMinutes  Int
  content           Json            // Structured lesson content
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  
  // Relationships
  challenge         Challenge?      @relation(fields: [challengeId], references: [id])
  completions       LessonCompletion[]
  
  @@index([languageCode, proficiencyLevel])
}

model LessonCompletion {
  id                String          @id @default(uuid())
  userId            String
  lessonId          String
  completedAt       DateTime        @default(now())
  timeSpentMinutes  Int
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade) 
  lesson            Lesson          @relation(fields: [lessonId], references: [id])
  
  @@unique([userId, lessonId])
}

// AI Conversation system
model AIConversation {
  id                String          @id @default(uuid())
  userId            String
  languageCode      String
  avatarType        String          // Type of AI character/avatar used
  startedAt         DateTime        @default(now())
  endedAt           DateTime?
  durationMinutes   Int?
  userChallengeId   String?         // Optional link to a challenge
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  messages          ConversationMessage[]
  evaluations       ConversationEvaluation?
  
  @@index([userId, startedAt])
}

model ConversationMessage {
  id                String          @id @default(uuid())
  conversationId    String
  sender            MessageSender
  content           String          // Text content
  audioUrl          String?         // URL to audio recording
  timestamp         DateTime        @default(now())
  
  // Relationships
  conversation      AIConversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@index([conversationId, timestamp])
}

enum MessageSender {
  USER
  AI
}

model ConversationEvaluation {
  id                String          @id @default(uuid())
  conversationId    String          @unique
  grammarScore      Float           // 0-100
  vocabularyScore   Float           // 0-100
  pronunciationScore Float          // 0-100
  fluencyScore      Float           // 0-100
  overallScore      Float           // 0-100
  feedback          String          // Detailed feedback
  evaluatedAt       DateTime        @default(now())
  
  // Relationships
  conversation      AIConversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  
  @@index([conversationId])
}

// Progress tracking
model ProgressRecord {
  id                String          @id @default(uuid())
  userId            String
  languageCode      String
  recordDate        DateTime        @default(now())
  vocabularySize    Int?            // Estimated vocabulary size
  grammarAccuracy   Float?          // 0-100
  speakingFluency   Float?          // 0-100
  listeningComprehension Float?     // 0-100
  overallLevel      ProficiencyLevel?
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, languageCode, recordDate])
}

// Achievement system
model Achievement {
  id                String          @id @default(uuid())
  name              String          @unique
  description       String
  badgeUrl          String
  achievementType   AchievementType
  threshold         Int             // Value needed to earn achievement
  
  // Relationships
  userAchievements  UserAchievement[]
}

enum AchievementType {
  STREAK_DAYS
  CONVERSATION_COUNT
  VOCABULARY_SIZE
  CHALLENGE_COMPLETED
  PRACTICE_HOURS
}

model UserAchievement {
  id                String          @id @default(uuid())
  userId            String
  achievementId     String
  earnedAt          DateTime        @default(now())
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement       Achievement     @relation(fields: [achievementId], references: [id])
  
  @@unique([userId, achievementId])
}

// Notification system
model Notification {
  id                String          @id @default(uuid())
  userId            String
  type              NotificationType
  title             String
  message           String
  read              Boolean         @default(false)
  createdAt         DateTime        @default(now())
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, read])
}

enum NotificationType {
  CHALLENGE_REMINDER
  STREAK_WARNING
  ACHIEVEMENT_EARNED
  CHALLENGE_COMPLETED
  STAKE_CONFIRMED
  REWARD_DISTRIBUTED
}

// Financial transactions
model Transaction {
  id                String          @id @default(uuid())
  userId            String
  transactionType   TransactionType
  amount            Float
  currency          String          // e.g., "USDC"
  txHash            String?         // Blockchain transaction hash
  status            TransactionStatus
  createdAt         DateTime        @default(now())
  completedAt       DateTime?
  
  // Relationships
  user              User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@index([userId, transactionType])
  @@index([txHash])
}

enum TransactionType {
  STAKE
  UNSTAKE
  REWARD
  YIELD
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
}



================================================================
End of Codebase
================================================================
